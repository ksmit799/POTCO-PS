1399435303
2 2
13 libp3pipeline 4 kd_i 4 core 
116
114 29 upcast_to_TypedReferenceCount 0 12 230 44 AsyncTaskBase::upcast_to_TypedReferenceCount 0 1 2 48
upcast from AsyncTaskBase to TypedReferenceCount
72
TypedReferenceCount *AsyncTaskBase::upcast_to_TypedReferenceCount(void);

115 25 downcast_to_AsyncTaskBase 0 12 231 46 TypedReferenceCount::downcast_to_AsyncTaskBase 0 1 3 50
downcast from TypedReferenceCount to AsyncTaskBase
68
AsyncTaskBase *TypedReferenceCount::downcast_to_AsyncTaskBase(void);

116 17 upcast_to_Namable 0 12 230 32 AsyncTaskBase::upcast_to_Namable 0 1 4 36
upcast from AsyncTaskBase to Namable
48
Namable *AsyncTaskBase::upcast_to_Namable(void);

117 25 downcast_to_AsyncTaskBase 0 12 232 34 Namable::downcast_to_AsyncTaskBase 0 1 5 38
downcast from Namable to AsyncTaskBase
56
AsyncTaskBase *Namable::downcast_to_AsyncTaskBase(void);

118 14 ~AsyncTaskBase 0 6 230 29 AsyncTaskBase::~AsyncTaskBase 0 0 233
////////////////////////////////////////////////////////////////////
//     Function: AsyncTaskBase::Destructor
//       Access: Published, Virtual
//  Description:
////////////////////////////////////////////////////////////////////
44
virtual AsyncTaskBase::~AsyncTaskBase(void);

119 14 get_class_type 0 4 230 29 AsyncTaskBase::get_class_type 0 1 1 0
54
static TypeHandle AsyncTaskBase::get_class_type(void);

120 29 upcast_to_TypedReferenceCount 0 12 234 37 Thread::upcast_to_TypedReferenceCount 0 1 36 41
upcast from Thread to TypedReferenceCount
65
TypedReferenceCount *Thread::upcast_to_TypedReferenceCount(void);

121 18 downcast_to_Thread 0 12 231 39 TypedReferenceCount::downcast_to_Thread 0 1 37 43
downcast from TypedReferenceCount to Thread
54
Thread *TypedReferenceCount::downcast_to_Thread(void);

122 17 upcast_to_Namable 0 12 234 25 Thread::upcast_to_Namable 0 1 38 29
upcast from Thread to Namable
41
Namable *Thread::upcast_to_Namable(void);

123 18 downcast_to_Thread 0 12 232 27 Namable::downcast_to_Thread 0 1 39 31
downcast from Namable to Thread
42
Thread *Namable::downcast_to_Thread(void);

124 7 ~Thread 0 6 234 15 Thread::~Thread 0 0 226
////////////////////////////////////////////////////////////////////
//     Function: Thread::Destructor
//       Access: Published, Virtual
//  Description:
////////////////////////////////////////////////////////////////////
30
virtual Thread::~Thread(void);

125 11 bind_thread 0 4 234 19 Thread::bind_thread 0 1 6 1438
////////////////////////////////////////////////////////////////////
//     Function: Thread::bind_thread
//       Access: Published, Static
//  Description: Returns a new Panda Thread object associated with the
//               current thread (which has been created externally).
//               This can be used to bind a unique Panda Thread object
//               with an external thread, such as a new Python thread.
//
//               It is particularly useful to bind a Panda Thread
//               object to an external thread for the purposes of
//               PStats monitoring.  Without this call, each external
//               thread will be assigned the same global
//               ExternalThread object, which means they will all
//               appear in the same PStats graph.
//
//               It is the caller's responsibility to save the
//               returned Thread pointer for the lifetime of the
//               external thread.  It is an error for the Thread
//               pointer to destruct while the external thread is
//               still in the system.
//
//               It is also an error to call this method from the main
//               thread, or twice within a given thread, unless it is
//               given the same name each time (in which case the same
//               pointer will be returned each time).
////////////////////////////////////////////////////////////////////
120
static PointerTo< Thread > Thread::bind_thread(basic_string< char > const &name, basic_string< char > const &sync_name);

126 13 get_sync_name 0 4 234 21 Thread::get_sync_name 0 1 7 565
////////////////////////////////////////////////////////////////////
//     Function: Thread::get_sync_name
//       Access: Published
//  Description: Returns the sync name of the thread.  This name
//               collects threads into "sync groups", which are
//               expected to run synchronously.  This is mainly used
//               for the benefit of PStats; threads with the same sync
//               name can be ticked all at once via the thread_tick()
//               call.
////////////////////////////////////////////////////////////////////
69
inline basic_string< char > const &Thread::get_sync_name(void) const;

127 16 get_pstats_index 0 4 234 24 Thread::get_pstats_index 0 1 8 476
////////////////////////////////////////////////////////////////////
//     Function: Thread::get_pstats_index
//       Access: Published
//  Description: Returns the PStats index associated with this thread,
//               or -1 if no index has yet been associated with this
//               thread.  This is used internally by the PStatClient;
//               you should not need to call this directly.
////////////////////////////////////////////////////////////////////
48
inline int Thread::get_pstats_index(void) const;

128 13 get_unique_id 0 4 234 21 Thread::get_unique_id 0 1 9 402
////////////////////////////////////////////////////////////////////
//     Function: Thread::get_unique_id
//       Access: Published
//  Description: Returns a string that is guaranteed to be unique to
//               this thread, across all processes on the machine,
//               during at least the lifetime of this process.
////////////////////////////////////////////////////////////////////
62
inline basic_string< char > Thread::get_unique_id(void) const;

129 18 get_pipeline_stage 0 4 234 26 Thread::get_pipeline_stage 0 1 10 409
////////////////////////////////////////////////////////////////////
//     Function: Thread::get_pipeline_stage
//       Access: Published
//  Description: Returns the Pipeline stage number associated with
//               this thread.  The default stage is 0 if no stage is
//               specified otherwise.  See set_pipeline_stage().
////////////////////////////////////////////////////////////////////
50
inline int Thread::get_pipeline_stage(void) const;

130 18 set_pipeline_stage 0 4 234 26 Thread::set_pipeline_stage 0 1 11 831
////////////////////////////////////////////////////////////////////
//     Function: Thread::set_pipeline_stage
//       Access: Published
//  Description: Specifies the Pipeline stage number associated with
//               this thread.  The default stage is 0 if no stage is
//               specified otherwise.
//
//               This must be a value in the range [0
//               .. pipeline->get_num_stages() - 1].  It specifies the
//               values that this thread observes for all pipelined
//               data.  Typically, an application thread will leave
//               this at 0, but a render thread may set it to 1 or 2
//               (to operate on the previous frame's data, or the
//               second previous frame's data).
////////////////////////////////////////////////////////////////////
52
void Thread::set_pipeline_stage(int pipeline_stage);

131 22 set_min_pipeline_stage 0 4 234 30 Thread::set_min_pipeline_stage 0 1 12 392
////////////////////////////////////////////////////////////////////
//     Function: Thread::set_min_pipeline_stage
//       Access: Published
//  Description: Sets this thread's pipeline stage number to at least
//               the indicated value, unless it is already larger.
//               See set_pipeline_stage().
////////////////////////////////////////////////////////////////////
67
inline void Thread::set_min_pipeline_stage(int min_pipeline_stage);

132 15 get_main_thread 0 4 234 23 Thread::get_main_thread 0 1 13 345
////////////////////////////////////////////////////////////////////
//     Function: Thread::get_main_thread
//       Access: Published, Static
//  Description: Returns a pointer to the "main" Thread object--this
//               is the Thread that started the whole process.
////////////////////////////////////////////////////////////////////
52
static inline Thread *Thread::get_main_thread(void);

133 19 get_external_thread 0 4 234 27 Thread::get_external_thread 0 1 14 531
////////////////////////////////////////////////////////////////////
//     Function: Thread::get_external_thread
//       Access: Published, Static
//  Description: Returns a pointer to the "external" Thread
//               object--this is a special Thread object that
//               corresponds to any thread spawned outside of Panda's
//               threading interface.  Note that multiple different
//               threads may share this same pointer.
////////////////////////////////////////////////////////////////////
56
static inline Thread *Thread::get_external_thread(void);

134 18 get_current_thread 0 4 234 26 Thread::get_current_thread 0 1 15 738
////////////////////////////////////////////////////////////////////
//     Function: Thread::get_current_thread
//       Access: Published, Static
//  Description: Returns a pointer to the currently-executing Thread
//               object.  If this is called from the main thread, this
//               will return the same value as get_main_thread().
//
//               This will always return some valid Thread pointer.
//               It will never return NULL, even if the current thread
//               was spawned outside of Panda's threading system,
//               although all non-Panda threads will return the exact
//               same Thread pointer.
////////////////////////////////////////////////////////////////////
55
static inline Thread *Thread::get_current_thread(void);

135 26 get_current_pipeline_stage 0 4 234 34 Thread::get_current_pipeline_stage 0 1 16 485
////////////////////////////////////////////////////////////////////
//     Function: Thread::get_current_pipeline_stage
//       Access: Published, Static
//  Description: Returns the integer pipeline stage associated with
//               the current thread.  This is the same thing as
//               get_current_thread()->get_pipeline_stage(), but it
//               may be faster to retrieve in some contexts.
////////////////////////////////////////////////////////////////////
59
static inline int Thread::get_current_pipeline_stage(void);

136 22 is_threading_supported 0 4 234 30 Thread::is_threading_supported 0 1 17 417
////////////////////////////////////////////////////////////////////
//     Function: Thread::is_threading_supported
//       Access: Published, Static
//  Description: Returns true if threading support has been compiled
//               in and enabled, or false if no threading is available
//               (and Thread::start() will always fail).
////////////////////////////////////////////////////////////////////
56
static inline bool Thread::is_threading_supported(void);

137 15 is_true_threads 0 4 234 23 Thread::is_true_threads 0 1 18 461
////////////////////////////////////////////////////////////////////
//     Function: Thread::is_true_threads
//       Access: Published, Static
//  Description: Returns true if a real threading library is available
//               that supports actual OS-implemented threads, or false
//               if the only threading we can provide is simulated
//               user-space threading.
////////////////////////////////////////////////////////////////////
49
static inline bool Thread::is_true_threads(void);

138 17 is_simple_threads 0 4 234 25 Thread::is_simple_threads 0 1 19 722
////////////////////////////////////////////////////////////////////
//     Function: Thread::is_simple_threads
//       Access: Published, Static
//  Description: Returns true if Panda is currently compiled for
//               "simple threads", which is to say, cooperative
//               context switching only, reducing the need for quite
//               so many critical section protections.  This is not
//               necessarily the opposite of "true threads", since one
//               possible implementation of simple threads is via true
//               threads with mutex protection to ensure only one runs
//               at a time.
////////////////////////////////////////////////////////////////////
51
static inline bool Thread::is_simple_threads(void);

139 5 sleep 0 4 234 13 Thread::sleep 0 1 20 360
////////////////////////////////////////////////////////////////////
//     Function: Thread::sleep
//       Access: Published, Static
//  Description: Suspends the current thread for at least the
//               indicated amount of time.  It might be suspended for
//               longer.
////////////////////////////////////////////////////////////////////
49
static inline void Thread::sleep(double seconds);

140 11 force_yield 0 4 234 19 Thread::force_yield 0 1 21 306
////////////////////////////////////////////////////////////////////
//     Function: Thread::field_yield
//       Access: Published, Static
//  Description: Suspends the current thread for the rest of the
//               current epoch.
////////////////////////////////////////////////////////////////////
45
static inline void Thread::force_yield(void);

141 14 consider_yield 0 4 234 22 Thread::consider_yield 0 1 22 520
////////////////////////////////////////////////////////////////////
//     Function: Thread::consider_yield
//       Access: Published, Static
//  Description: Possibly suspends the current thread for the rest of
//               the current epoch, if it has run for enough this
//               epoch.  This is especially important for the simple
//               thread implementation, which relies on cooperative
//               yields like this.
////////////////////////////////////////////////////////////////////
48
static inline void Thread::consider_yield(void);

142 6 output 0 6 234 14 Thread::output 0 1 23 222
////////////////////////////////////////////////////////////////////
//     Function: Thread::output
//       Access: Published, Virtual
//  Description:
////////////////////////////////////////////////////////////////////
48
virtual void Thread::output(ostream &out) const;

143 14 output_blocker 0 4 234 22 Thread::output_blocker 0 1 24 440
////////////////////////////////////////////////////////////////////
//     Function: Thread::output_blocker
//       Access: Published
//  Description: Writes a description of the mutex or condition
//               variable that this thread is blocked on.  Writes
//               nothing if there is no blocker, or if we are not in
//               DEBUG_THREADS mode.
////////////////////////////////////////////////////////////////////
48
void Thread::output_blocker(ostream &out) const;

144 12 write_status 0 4 234 20 Thread::write_status 0 1 25 227
////////////////////////////////////////////////////////////////////
//     Function: Thread::write_status
//       Access: Published, Static
//  Description:
////////////////////////////////////////////////////////////////////
47
static void Thread::write_status(ostream &out);

145 10 is_started 0 4 234 18 Thread::is_started 0 1 26 338
////////////////////////////////////////////////////////////////////
//     Function: Thread::is_started
//       Access: Published
//  Description: Returns true if the thread has been started, false if
//               it has not, or if join() has already been called.
////////////////////////////////////////////////////////////////////
43
inline bool Thread::is_started(void) const;

146 11 is_joinable 0 4 234 19 Thread::is_joinable 0 1 27 302
////////////////////////////////////////////////////////////////////
//     Function: Thread::is_joinable
//       Access: Published
//  Description: Returns the value of joinable that was passed to the
//               start() call.
////////////////////////////////////////////////////////////////////
44
inline bool Thread::is_joinable(void) const;

147 5 start 0 4 234 13 Thread::start 0 1 28 1333
////////////////////////////////////////////////////////////////////
//     Function: Thread::start
//       Access: Public
//  Description: Starts the thread executing.  It is only valid to
//               call this once.
//
//               The thread will begin executing its thread_main()
//               function, and will terminate when thread_main()
//               returns.
//
//               priority is intended as a hint to the relative
//               importance of this thread.  This may be ignored by
//               the thread implementation.
//
//               joinable should be set true if you intend to call
//               join() to wait for the thread to terminate, or false
//               if you don't care and you will never call join().
//               Note that the reference count on the Thread object is
//               incremented while the thread itself is running, so if
//               you just want to fire and forget a thread, you may
//               pass joinable = false, and never store the Thread
//               object.  It will automatically destruct itself when
//               it finishes.
//
//               The return value is true if the thread is
//               successfully started, false otherwise.
////////////////////////////////////////////////////////////////////
59
bool Thread::start(ThreadPriority priority, bool joinable);

148 4 join 0 4 234 12 Thread::join 0 1 29 366
////////////////////////////////////////////////////////////////////
//     Function: Thread::join
//       Access: Published
//  Description: Blocks the calling process until the thread
//               terminates.  If the thread has already terminated,
//               this returns immediately.
////////////////////////////////////////////////////////////////////
31
inline void Thread::join(void);

149 7 preempt 0 4 234 15 Thread::preempt 0 1 30 432
////////////////////////////////////////////////////////////////////
//     Function: Thread::preempt
//       Access: Published
//  Description: Indicates that this thread should run as soon as
//               possible, preemptying any other threads that may be
//               scheduled to run.  This may not be implemented on
//               every platform.
////////////////////////////////////////////////////////////////////
34
inline void Thread::preempt(void);

150 15 set_python_data 0 4 234 23 Thread::set_python_data 0 1 31 543
////////////////////////////////////////////////////////////////////
//     Function: Thread::set_python_data
//       Access: Published
//  Description: Sets an arbitrary Python object that may be
//               associated with this thread object.  This is just for
//               the purposes of associated arbitrary Python data with
//               the C++ object; other than managing the reference
//               count, the C++ code does nothing with this object.
////////////////////////////////////////////////////////////////////
52
void Thread::set_python_data(PyObject *python_data);

151 15 get_python_data 0 4 234 23 Thread::get_python_data 0 1 32 302
////////////////////////////////////////////////////////////////////
//     Function: Thread::get_python_data
//       Access: Published
//  Description: Returns the Python object that was set with
//               set_python_data().
////////////////////////////////////////////////////////////////////
46
PyObject *Thread::get_python_data(void) const;

152 16 get_current_task 0 4 234 24 Thread::get_current_task 0 1 33 402
////////////////////////////////////////////////////////////////////
//     Function: Thread::get_current_task
//       Access: Published
//  Description: Returns the task currently executing on this thread
//               (via the AsyncTaskManager), if any, or NULL if the
//               thread is not currently servicing a task.
////////////////////////////////////////////////////////////////////
59
inline AsyncTaskBase *Thread::get_current_task(void) const;

153 16 prepare_for_exit 0 4 234 24 Thread::prepare_for_exit 0 1 34 387
////////////////////////////////////////////////////////////////////
//     Function: Thread::prepare_for_exit
//       Access: Published
//  Description: Should be called by the main thread just before
//               exiting the program, this blocks until any remaining
//               thread cleanup has finished.
////////////////////////////////////////////////////////////////////
50
static inline void Thread::prepare_for_exit(void);

154 14 get_class_type 0 4 234 22 Thread::get_class_type 0 1 35 0
47
static TypeHandle Thread::get_class_type(void);

155 7 acquire 0 4 235 20 MutexDirect::acquire 0 1 40 735
////////////////////////////////////////////////////////////////////
//     Function: MutexDirect::acquire
//       Access: Published
//  Description: Grabs the mutex if it is available.  If it is not
//               available, blocks until it becomes available, then
//               grabs it.  In either case, the function does not
//               return until the mutex is held; you should then call
//               unlock().
//
//               This method is considered const so that you can lock
//               and unlock const mutexes, mainly to allow thread-safe
//               access to otherwise const data.
//
//               Also see MutexHolder.
////////////////////////////////////////////////////////////////////
45
inline void MutexDirect::acquire(void) const;

156 11 try_acquire 0 4 235 24 MutexDirect::try_acquire 0 1 41 369
////////////////////////////////////////////////////////////////////
//     Function: MutexDirect::try_acquire
//       Access: Published
//  Description: Returns immediately, with a true value indicating the
//               mutex has been acquired, and false indicating it has
//               not.
////////////////////////////////////////////////////////////////////
49
inline bool MutexDirect::try_acquire(void) const;

157 7 release 0 4 235 20 MutexDirect::release 0 1 42 515
////////////////////////////////////////////////////////////////////
//     Function: MutexDirect::release
//       Access: Published
//  Description: Releases the mutex.  It is an error to call this if
//               the mutex was not already locked.
//
//               This method is considered const so that you can lock
//               and unlock const mutexes, mainly to allow thread-safe
//               access to otherwise const data.
////////////////////////////////////////////////////////////////////
45
inline void MutexDirect::release(void) const;

158 15 debug_is_locked 0 4 235 28 MutexDirect::debug_is_locked 0 1 43 572
////////////////////////////////////////////////////////////////////
//     Function: MutexDirect::debug_is_locked
//       Access: Published
//  Description: Returns true if the current thread has locked the
//               Mutex, false otherwise.  This method is only intended
//               for use in debugging, hence the method name; in the
//               MutexDirect case, it always returns true, since
//               there's not a reliable way to determine this
//               otherwise.
////////////////////////////////////////////////////////////////////
53
inline bool MutexDirect::debug_is_locked(void) const;

159 8 set_name 0 4 235 21 MutexDirect::set_name 0 1 44 303
////////////////////////////////////////////////////////////////////
//     Function: MutexDirect::set_name
//       Access: Public
//  Description: The mutex name is only defined when compiling in
//               DEBUG_THREADS mode.
////////////////////////////////////////////////////////////////////
68
inline void MutexDirect::set_name(basic_string< char > const &name);

160 10 clear_name 0 4 235 23 MutexDirect::clear_name 0 1 45 305
////////////////////////////////////////////////////////////////////
//     Function: MutexDirect::clear_name
//       Access: Public
//  Description: The mutex name is only defined when compiling in
//               DEBUG_THREADS mode.
////////////////////////////////////////////////////////////////////
42
inline void MutexDirect::clear_name(void);

161 8 has_name 0 4 235 21 MutexDirect::has_name 0 1 46 303
////////////////////////////////////////////////////////////////////
//     Function: MutexDirect::has_name
//       Access: Public
//  Description: The mutex name is only defined when compiling in
//               DEBUG_THREADS mode.
////////////////////////////////////////////////////////////////////
46
inline bool MutexDirect::has_name(void) const;

162 8 get_name 0 4 235 21 MutexDirect::get_name 0 1 47 303
////////////////////////////////////////////////////////////////////
//     Function: MutexDirect::get_name
//       Access: Public
//  Description: The mutex name is only defined when compiling in
//               DEBUG_THREADS mode.
////////////////////////////////////////////////////////////////////
62
inline basic_string< char > MutexDirect::get_name(void) const;

163 6 output 0 4 235 19 MutexDirect::output 0 1 48 311
////////////////////////////////////////////////////////////////////
//     Function: MutexDirect::output
//       Access: Public
//  Description: This method is declared virtual in MutexDebug, but
//               non-virtual in MutexDirect.
////////////////////////////////////////////////////////////////////
45
void MutexDirect::output(ostream &out) const;

164 5 Mutex 0 4 236 12 Mutex::Mutex 0 2 49 50 1388
// Filename: pmutex.I
// Created by:  drose (08Aug02)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: Mutex::Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: Mutex::Constructor
//       Access: Public
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: Mutex::Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: Mutex::Copy Constructor
//       Access: Private
//  Description: Do not attempt to copy mutexes.
////////////////////////////////////////////////////////////////////
81
inline Mutex::Mutex(void);
inline Mutex::Mutex(basic_string< char > const &name);

165 6 ~Mutex 0 4 236 13 Mutex::~Mutex 0 0 216
////////////////////////////////////////////////////////////////////
//     Function: Mutex::Destructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
27
inline Mutex::~Mutex(void);

166 19 ~ConditionVarDirect 0 4 237 39 ConditionVarDirect::~ConditionVarDirect 0 0 226
////////////////////////////////////////////////////////////////////
//     Function: ConditionVarDirect::Destructor
//       Access: Public
//  Description:
////////////////////////////////////////////////////////////////////
53
inline ConditionVarDirect::~ConditionVarDirect(void);

167 9 get_mutex 0 4 237 29 ConditionVarDirect::get_mutex 0 1 51 301
////////////////////////////////////////////////////////////////////
//     Function: ConditionVarDirect::get_mutex
//       Access: Public
//  Description: Returns the mutex associated with this condition
//               variable.
////////////////////////////////////////////////////////////////////
62
inline MutexDirect &ConditionVarDirect::get_mutex(void) const;

168 4 wait 0 4 237 24 ConditionVarDirect::wait 0 2 52 53 1945
////////////////////////////////////////////////////////////////////
//     Function: ConditionVarDirect::wait
//       Access: Public
//  Description: Waits on the condition.  The caller must already be
//               holding the lock associated with the condition
//               variable before calling this function.
//
//               wait() will release the lock, then go to sleep until
//               some other thread calls notify() on this condition
//               variable.  At that time at least one thread waiting
//               on the same ConditionVarDirect will grab the lock again,
//               and then return from wait().
//
//               It is possible that wait() will return even if no one
//               has called notify().  It is the responsibility of the
//               calling process to verify the condition on return
//               from wait, and possibly loop back to wait again if
//               necessary.
//
//               Note the semantics of a condition variable: the mutex
//               must be held before wait() is called, and it will
//               still be held when wait() returns.  However, it will
//               be temporarily released during the wait() call
//               itself.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: ConditionVarDirect::wait
//       Access: Published
//  Description: Waits on the condition, with a timeout.  The function
//               will return when the condition variable is notified,
//               or the timeout occurs.  There is no way to directly
//               tell which happened, and it is possible that neither
//               in fact happened (spurious wakeups are possible).
//
//               See wait() with no parameters for more.
////////////////////////////////////////////////////////////////////
97
inline void ConditionVarDirect::wait(void);
inline void ConditionVarDirect::wait(double timeout);

169 6 notify 0 4 237 26 ConditionVarDirect::notify 0 1 54 903
////////////////////////////////////////////////////////////////////
//     Function: ConditionVarDirect::notify
//       Access: Public
//  Description: Informs one of the other threads who are currently
//               blocked on wait() that the relevant condition has
//               changed.  If multiple threads are currently waiting,
//               at least one of them will be woken up, although there
//               is no way to predict which one.  It is possible that
//               more than one thread will be woken up.
//
//               The caller must be holding the mutex associated with
//               the condition variable before making this call, which
//               will not release the mutex.
//
//               If no threads are waiting, this is a no-op: the
//               notify event is lost.
////////////////////////////////////////////////////////////////////
45
inline void ConditionVarDirect::notify(void);

170 6 output 0 4 237 26 ConditionVarDirect::output 0 1 55 332
////////////////////////////////////////////////////////////////////
//     Function: ConditionVarDirect::output
//       Access: Public
//  Description: This method is declared virtual in ConditionVarDebug,
//               but non-virtual in ConditionVarDirect.
////////////////////////////////////////////////////////////////////
52
void ConditionVarDirect::output(ostream &out) const;

171 12 ConditionVar 0 4 238 26 ConditionVar::ConditionVar 0 1 56 1329
// Filename: conditionVar.I
// Created by:  drose (09Aug02)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: ConditionVar::Constructor
//       Access: Published
//  Description: You must pass in a Mutex to the condition variable
//               constructor.  This mutex may be shared by other
//               condition variables, if desired.  It is the caller's
//               responsibility to ensure the Mutex object does not
//               destruct during the lifetime of the condition
//               variable.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: ConditionVar::Copy Constructor
//       Access: Private
//  Description: Do not attempt to copy condition variables.
////////////////////////////////////////////////////////////////////
48
inline ConditionVar::ConditionVar(Mutex &mutex);

172 13 ~ConditionVar 0 4 238 27 ConditionVar::~ConditionVar 0 0 223
////////////////////////////////////////////////////////////////////
//     Function: ConditionVar::Destructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
41
inline ConditionVar::~ConditionVar(void);

173 9 get_mutex 0 4 238 23 ConditionVar::get_mutex 0 1 57 298
////////////////////////////////////////////////////////////////////
//     Function: ConditionVar::get_mutex
//       Access: Published
//  Description: Returns the mutex associated with this condition
//               variable.
////////////////////////////////////////////////////////////////////
50
inline Mutex &ConditionVar::get_mutex(void) const;

174 23 ~ConditionVarFullDirect 0 4 239 47 ConditionVarFullDirect::~ConditionVarFullDirect 0 0 230
////////////////////////////////////////////////////////////////////
//     Function: ConditionVarFullDirect::Destructor
//       Access: Public
//  Description:
////////////////////////////////////////////////////////////////////
61
inline ConditionVarFullDirect::~ConditionVarFullDirect(void);

175 9 get_mutex 0 4 239 33 ConditionVarFullDirect::get_mutex 0 1 58 308
////////////////////////////////////////////////////////////////////
//     Function: ConditionVarFullDirect::get_mutex
//       Access: Published
//  Description: Returns the mutex associated with this condition
//               variable.
////////////////////////////////////////////////////////////////////
66
inline MutexDirect &ConditionVarFullDirect::get_mutex(void) const;

176 4 wait 0 4 239 28 ConditionVarFullDirect::wait 0 2 59 60 1960
////////////////////////////////////////////////////////////////////
//     Function: ConditionVarFullDirect::wait
//       Access: Published
//  Description: Waits on the condition.  The caller must already be
//               holding the lock associated with the condition
//               variable before calling this function.
//
//               wait() will release the lock, then go to sleep until
//               some other thread calls notify() on this condition
//               variable.  At that time at least one thread waiting
//               on the same ConditionVarFullDirect will grab the lock again,
//               and then return from wait().
//
//               It is possible that wait() will return even if no one
//               has called notify().  It is the responsibility of the
//               calling process to verify the condition on return
//               from wait, and possibly loop back to wait again if
//               necessary.
//
//               Note the semantics of a condition variable: the mutex
//               must be held before wait() is called, and it will
//               still be held when wait() returns.  However, it will
//               be temporarily released during the wait() call
//               itself.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: ConditionVarFullDirect::wait
//       Access: Published
//  Description: Waits on the condition, with a timeout.  The function
//               will return when the condition variable is notified,
//               or the timeout occurs.  There is no way to directly
//               tell which happened, and it is possible that neither
//               in fact happened (spurious wakeups are possible).
//
//               See wait() with no parameters for more.
////////////////////////////////////////////////////////////////////
105
inline void ConditionVarFullDirect::wait(void);
inline void ConditionVarFullDirect::wait(double timeout);

177 6 notify 0 4 239 30 ConditionVarFullDirect::notify 0 1 61 904
////////////////////////////////////////////////////////////////////
//     Function: ConditionVarFullDirect::notify
//       Access: Published
//  Description: Informs one of the other threads who are currently
//               blocked on wait() that the relevant condition has
//               changed.  If multiple threads are currently waiting,
//               at least one of them will be woken up, although there
//               is no way to predict which one.  It is possible that
//               more than one thread will be woken up.
//
//               The caller must be holding the mutex associated with
//               the condition variable before making this call, which
//               will not release the mutex.
//
//               If no threads are waiting, this is a no-op: the
//               notify is lost.
////////////////////////////////////////////////////////////////////
49
inline void ConditionVarFullDirect::notify(void);

178 10 notify_all 0 4 239 34 ConditionVarFullDirect::notify_all 0 1 62 673
////////////////////////////////////////////////////////////////////
//     Function: ConditionVarFullDirect::notify_all
//       Access: Published
//  Description: Informs all of the other threads who are currently
//               blocked on wait() that the relevant condition has
//               changed.
//
//               The caller must be holding the mutex associated with
//               the condition variable before making this call, which
//               will not release the mutex.
//
//               If no threads are waiting, this is a no-op: the
//               notify event is lost.
////////////////////////////////////////////////////////////////////
53
inline void ConditionVarFullDirect::notify_all(void);

179 6 output 0 4 239 30 ConditionVarFullDirect::output 0 1 63 344
////////////////////////////////////////////////////////////////////
//     Function: ConditionVarFullDirect::output
//       Access: Public
//  Description: This method is declared virtual in ConditionVarFullDebug,
//               but non-virtual in ConditionVarFullDirect.
////////////////////////////////////////////////////////////////////
56
void ConditionVarFullDirect::output(ostream &out) const;

180 16 ConditionVarFull 0 4 240 34 ConditionVarFull::ConditionVarFull 0 1 64 1341
// Filename: conditionVarFull.I
// Created by:  drose (28Aug06)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: ConditionVarFull::Constructor
//       Access: Published
//  Description: You must pass in a Mutex to the condition variable
//               constructor.  This mutex may be shared by other
//               condition variables, if desired.  It is the caller's
//               responsibility to ensure the Mutex object does not
//               destruct during the lifetime of the condition
//               variable.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: ConditionVarFull::Copy Constructor
//       Access: Private
//  Description: Do not attempt to copy condition variables.
////////////////////////////////////////////////////////////////////
56
inline ConditionVarFull::ConditionVarFull(Mutex &mutex);

181 17 ~ConditionVarFull 0 4 240 35 ConditionVarFull::~ConditionVarFull 0 0 227
////////////////////////////////////////////////////////////////////
//     Function: ConditionVarFull::Destructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
49
inline ConditionVarFull::~ConditionVarFull(void);

182 9 get_mutex 0 4 240 27 ConditionVarFull::get_mutex 0 1 65 302
////////////////////////////////////////////////////////////////////
//     Function: ConditionVarFull::get_mutex
//       Access: Published
//  Description: Returns the mutex associated with this condition
//               variable.
////////////////////////////////////////////////////////////////////
54
inline Mutex &ConditionVarFull::get_mutex(void) const;

183 7 acquire 0 4 241 22 ReMutexDirect::acquire 0 2 66 67 1115
////////////////////////////////////////////////////////////////////
//     Function: ReMutexDirect::acquire
//       Access: Published
//  Description: Grabs the reMutex if it is available.  If it is not
//               available, blocks until it becomes available, then
//               grabs it.  In either case, the function does not
//               return until the reMutex is held; you should then call
//               unlock().
//
//               This method is considered const so that you can lock
//               and unlock const reMutexes, mainly to allow thread-safe
//               access to otherwise const data.
//
//               Also see ReMutexHolder.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: ReMutexDirect::acquire
//       Access: Published
//  Description: This variant on acquire() accepts the current thread as
//               a parameter, if it is already known, as an
//               optimization.
////////////////////////////////////////////////////////////////////
113
inline void ReMutexDirect::acquire(void) const;
inline void ReMutexDirect::acquire(Thread *current_thread) const;

184 11 try_acquire 0 4 241 26 ReMutexDirect::try_acquire 0 2 68 69 744
////////////////////////////////////////////////////////////////////
//     Function: ReMutexDirect::try_acquire
//       Access: Published
//  Description: Returns immediately, with a true value indicating the
//               mutex has been acquired, and false indicating it has
//               not.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: ReMutexDirect::try_acquire
//       Access: Published
//  Description: Returns immediately, with a true value indicating the
//               mutex has been acquired, and false indicating it has
//               not.
////////////////////////////////////////////////////////////////////
121
inline bool ReMutexDirect::try_acquire(void) const;
inline bool ReMutexDirect::try_acquire(Thread *current_thread) const;

185 12 elevate_lock 0 4 241 27 ReMutexDirect::elevate_lock 0 1 70 819
////////////////////////////////////////////////////////////////////
//     Function: ReMutexDirect::elevate_lock
//       Access: Published
//  Description: This method increments the lock count, assuming the
//               calling thread already holds the lock.  After this
//               call, release() will need to be called one additional
//               time to release the lock.
//
//               This method really performs the same function as
//               acquire(), but it offers a potential (slight)
//               performance benefit when the calling thread knows
//               that it already holds the lock.  It is an error to
//               call this when the calling thread does not hold the
//               lock.
////////////////////////////////////////////////////////////////////
52
inline void ReMutexDirect::elevate_lock(void) const;

186 7 release 0 4 241 22 ReMutexDirect::release 0 1 71 523
////////////////////////////////////////////////////////////////////
//     Function: ReMutexDirect::release
//       Access: Published
//  Description: Releases the reMutex.  It is an error to call this if
//               the reMutex was not already locked.
//
//               This method is considered const so that you can lock
//               and unlock const reMutexes, mainly to allow thread-safe
//               access to otherwise const data.
////////////////////////////////////////////////////////////////////
47
inline void ReMutexDirect::release(void) const;

187 15 debug_is_locked 0 4 241 30 ReMutexDirect::debug_is_locked 0 1 72 578
////////////////////////////////////////////////////////////////////
//     Function: ReMutexDirect::debug_is_locked
//       Access: Published
//  Description: Returns true if the current thread has locked the
//               ReMutex, false otherwise.  This method is only intended
//               for use in debugging, hence the method name; in the
//               ReMutexDirect case, it always returns true, since
//               there's not a reliable way to determine this
//               otherwise.
////////////////////////////////////////////////////////////////////
55
inline bool ReMutexDirect::debug_is_locked(void) const;

188 8 set_name 0 4 241 23 ReMutexDirect::set_name 0 1 73 305
////////////////////////////////////////////////////////////////////
//     Function: ReMutexDirect::set_name
//       Access: Public
//  Description: The mutex name is only defined when compiling in
//               DEBUG_THREADS mode.
////////////////////////////////////////////////////////////////////
70
inline void ReMutexDirect::set_name(basic_string< char > const &name);

189 10 clear_name 0 4 241 25 ReMutexDirect::clear_name 0 1 74 307
////////////////////////////////////////////////////////////////////
//     Function: ReMutexDirect::clear_name
//       Access: Public
//  Description: The mutex name is only defined when compiling in
//               DEBUG_THREADS mode.
////////////////////////////////////////////////////////////////////
44
inline void ReMutexDirect::clear_name(void);

190 8 has_name 0 4 241 23 ReMutexDirect::has_name 0 1 75 305
////////////////////////////////////////////////////////////////////
//     Function: ReMutexDirect::has_name
//       Access: Public
//  Description: The mutex name is only defined when compiling in
//               DEBUG_THREADS mode.
////////////////////////////////////////////////////////////////////
48
inline bool ReMutexDirect::has_name(void) const;

191 8 get_name 0 4 241 23 ReMutexDirect::get_name 0 1 76 305
////////////////////////////////////////////////////////////////////
//     Function: ReMutexDirect::get_name
//       Access: Public
//  Description: The mutex name is only defined when compiling in
//               DEBUG_THREADS mode.
////////////////////////////////////////////////////////////////////
64
inline basic_string< char > ReMutexDirect::get_name(void) const;

192 6 output 0 4 241 21 ReMutexDirect::output 0 1 77 318
////////////////////////////////////////////////////////////////////
//     Function: ReMutexDirect::output
//       Access: Published
//  Description: This method is declared virtual in MutexDebug, but
//               non-virtual in ReMutexDirect.
////////////////////////////////////////////////////////////////////
47
void ReMutexDirect::output(ostream &out) const;

193 7 ReMutex 0 4 242 16 ReMutex::ReMutex 0 2 78 79 1135
// Filename: reMutex.I
// Created by:  drose (15Jan06)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: ReMutex::Constructor
//       Access: Public
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: ReMutex::Constructor
//       Access: Public
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: ReMutex::Constructor
//       Access: Public
//  Description:
////////////////////////////////////////////////////////////////////
89
inline ReMutex::ReMutex(void);
inline ReMutex::ReMutex(basic_string< char > const &name);

194 8 ~ReMutex 0 4 242 17 ReMutex::~ReMutex 0 0 215
////////////////////////////////////////////////////////////////////
//     Function: ReMutex::Destructor
//       Access: Public
//  Description:
////////////////////////////////////////////////////////////////////
31
inline ReMutex::~ReMutex(void);

195 14 get_class_type 0 4 243 30 ExternalThread::get_class_type 0 1 80 0
55
static TypeHandle ExternalThread::get_class_type(void);

196 15 ~ExternalThread 0 4 243 31 ExternalThread::~ExternalThread 0 0 0
38
ExternalThread::~ExternalThread(void);

197 7 acquire 0 4 244 25 LightMutexDirect::acquire 0 1 81 760
////////////////////////////////////////////////////////////////////
//     Function: LightMutexDirect::acquire
//       Access: Published
//  Description: Grabs the lightMutex if it is available.  If it is not
//               available, blocks until it becomes available, then
//               grabs it.  In either case, the function does not
//               return until the lightMutex is held; you should then call
//               unlock().
//
//               This method is considered const so that you can lock
//               and unlock const lightMutexes, mainly to allow thread-safe
//               access to otherwise const data.
//
//               Also see LightMutexHolder.
////////////////////////////////////////////////////////////////////
50
inline void LightMutexDirect::acquire(void) const;

198 7 release 0 4 244 25 LightMutexDirect::release 0 1 82 535
////////////////////////////////////////////////////////////////////
//     Function: LightMutexDirect::release
//       Access: Published
//  Description: Releases the lightMutex.  It is an error to call this if
//               the lightMutex was not already locked.
//
//               This method is considered const so that you can lock
//               and unlock const lightMutexes, mainly to allow thread-safe
//               access to otherwise const data.
////////////////////////////////////////////////////////////////////
50
inline void LightMutexDirect::release(void) const;

199 15 debug_is_locked 0 4 244 33 LightMutexDirect::debug_is_locked 0 1 83 587
////////////////////////////////////////////////////////////////////
//     Function: LightMutexDirect::debug_is_locked
//       Access: Published
//  Description: Returns true if the current thread has locked the
//               LightMutex, false otherwise.  This method is only intended
//               for use in debugging, hence the method name; in the
//               LightMutexDirect case, it always returns true, since
//               there's not a reliable way to determine this
//               otherwise.
////////////////////////////////////////////////////////////////////
58
inline bool LightMutexDirect::debug_is_locked(void) const;

200 8 set_name 0 4 244 26 LightMutexDirect::set_name 0 1 84 313
////////////////////////////////////////////////////////////////////
//     Function: LightMutexDirect::set_name
//       Access: Public
//  Description: The lightMutex name is only defined when compiling in
//               DEBUG_THREADS mode.
////////////////////////////////////////////////////////////////////
73
inline void LightMutexDirect::set_name(basic_string< char > const &name);

201 10 clear_name 0 4 244 28 LightMutexDirect::clear_name 0 1 85 315
////////////////////////////////////////////////////////////////////
//     Function: LightMutexDirect::clear_name
//       Access: Public
//  Description: The lightMutex name is only defined when compiling in
//               DEBUG_THREADS mode.
////////////////////////////////////////////////////////////////////
47
inline void LightMutexDirect::clear_name(void);

202 8 has_name 0 4 244 26 LightMutexDirect::has_name 0 1 86 313
////////////////////////////////////////////////////////////////////
//     Function: LightMutexDirect::has_name
//       Access: Public
//  Description: The lightMutex name is only defined when compiling in
//               DEBUG_THREADS mode.
////////////////////////////////////////////////////////////////////
51
inline bool LightMutexDirect::has_name(void) const;

203 8 get_name 0 4 244 26 LightMutexDirect::get_name 0 1 87 313
////////////////////////////////////////////////////////////////////
//     Function: LightMutexDirect::get_name
//       Access: Public
//  Description: The lightMutex name is only defined when compiling in
//               DEBUG_THREADS mode.
////////////////////////////////////////////////////////////////////
67
inline basic_string< char > LightMutexDirect::get_name(void) const;

204 6 output 0 4 244 24 LightMutexDirect::output 0 1 88 326
////////////////////////////////////////////////////////////////////
//     Function: LightMutexDirect::output
//       Access: Public
//  Description: This method is declared virtual in LightMutexDebug, but
//               non-virtual in LightMutexDirect.
////////////////////////////////////////////////////////////////////
50
void LightMutexDirect::output(ostream &out) const;

205 10 LightMutex 0 4 245 22 LightMutex::LightMutex 0 2 89 90 1417
// Filename: lightMutex.I
// Created by:  drose (08Oct08)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: LightMutex::Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: LightMutex::Constructor
//       Access: Public
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: LightMutex::Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: LightMutex::Copy Constructor
//       Access: Private
//  Description: Do not attempt to copy lightMutexes.
////////////////////////////////////////////////////////////////////
101
inline LightMutex::LightMutex(void);
inline LightMutex::LightMutex(basic_string< char > const &name);

206 11 ~LightMutex 0 4 245 23 LightMutex::~LightMutex 0 0 221
////////////////////////////////////////////////////////////////////
//     Function: LightMutex::Destructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
37
inline LightMutex::~LightMutex(void);

207 7 acquire 0 4 246 27 LightReMutexDirect::acquire 0 2 91 92 1145
////////////////////////////////////////////////////////////////////
//     Function: LightReMutexDirect::acquire
//       Access: Published
//  Description: Grabs the lightReMutex if it is available.  If it is not
//               available, blocks until it becomes available, then
//               grabs it.  In either case, the function does not
//               return until the lightReMutex is held; you should then call
//               unlock().
//
//               This method is considered const so that you can lock
//               and unlock const lightReMutexes, mainly to allow thread-safe
//               access to otherwise const data.
//
//               Also see LightReMutexHolder.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: LightReMutexDirect::acquire
//       Access: Published
//  Description: This variant on acquire() accepts the current thread as
//               a parameter, if it is already known, as an
//               optimization.
////////////////////////////////////////////////////////////////////
123
inline void LightReMutexDirect::acquire(void) const;
inline void LightReMutexDirect::acquire(Thread *current_thread) const;

208 12 elevate_lock 0 4 246 32 LightReMutexDirect::elevate_lock 0 1 93 824
////////////////////////////////////////////////////////////////////
//     Function: LightReMutexDirect::elevate_lock
//       Access: Published
//  Description: This method increments the lock count, assuming the
//               calling thread already holds the lock.  After this
//               call, release() will need to be called one additional
//               time to release the lock.
//
//               This method really performs the same function as
//               acquire(), but it offers a potential (slight)
//               performance benefit when the calling thread knows
//               that it already holds the lock.  It is an error to
//               call this when the calling thread does not hold the
//               lock.
////////////////////////////////////////////////////////////////////
57
inline void LightReMutexDirect::elevate_lock(void) const;

209 7 release 0 4 246 27 LightReMutexDirect::release 0 1 94 543
////////////////////////////////////////////////////////////////////
//     Function: LightReMutexDirect::release
//       Access: Published
//  Description: Releases the lightReMutex.  It is an error to call this if
//               the lightReMutex was not already locked.
//
//               This method is considered const so that you can lock
//               and unlock const lightReMutexes, mainly to allow thread-safe
//               access to otherwise const data.
////////////////////////////////////////////////////////////////////
52
inline void LightReMutexDirect::release(void) const;

210 15 debug_is_locked 0 4 246 35 LightReMutexDirect::debug_is_locked 0 1 95 593
////////////////////////////////////////////////////////////////////
//     Function: LightReMutexDirect::debug_is_locked
//       Access: Published
//  Description: Returns true if the current thread has locked the
//               LightReMutex, false otherwise.  This method is only intended
//               for use in debugging, hence the method name; in the
//               LightReMutexDirect case, it always returns true, since
//               there's not a reliable way to determine this
//               otherwise.
////////////////////////////////////////////////////////////////////
60
inline bool LightReMutexDirect::debug_is_locked(void) const;

211 8 set_name 0 4 246 28 LightReMutexDirect::set_name 0 1 96 310
////////////////////////////////////////////////////////////////////
//     Function: LightReMutexDirect::set_name
//       Access: Public
//  Description: The mutex name is only defined when compiling in
//               DEBUG_THREADS mode.
////////////////////////////////////////////////////////////////////
75
inline void LightReMutexDirect::set_name(basic_string< char > const &name);

212 10 clear_name 0 4 246 30 LightReMutexDirect::clear_name 0 1 97 312
////////////////////////////////////////////////////////////////////
//     Function: LightReMutexDirect::clear_name
//       Access: Public
//  Description: The mutex name is only defined when compiling in
//               DEBUG_THREADS mode.
////////////////////////////////////////////////////////////////////
49
inline void LightReMutexDirect::clear_name(void);

213 8 has_name 0 4 246 28 LightReMutexDirect::has_name 0 1 98 310
////////////////////////////////////////////////////////////////////
//     Function: LightReMutexDirect::has_name
//       Access: Public
//  Description: The mutex name is only defined when compiling in
//               DEBUG_THREADS mode.
////////////////////////////////////////////////////////////////////
53
inline bool LightReMutexDirect::has_name(void) const;

214 8 get_name 0 4 246 28 LightReMutexDirect::get_name 0 1 99 310
////////////////////////////////////////////////////////////////////
//     Function: LightReMutexDirect::get_name
//       Access: Public
//  Description: The mutex name is only defined when compiling in
//               DEBUG_THREADS mode.
////////////////////////////////////////////////////////////////////
69
inline basic_string< char > LightReMutexDirect::get_name(void) const;

215 6 output 0 4 246 26 LightReMutexDirect::output 0 1 100 328
////////////////////////////////////////////////////////////////////
//     Function: LightReMutexDirect::output
//       Access: Published
//  Description: This method is declared virtual in MutexDebug, but
//               non-virtual in LightReMutexDirect.
////////////////////////////////////////////////////////////////////
52
void LightReMutexDirect::output(ostream &out) const;

216 12 LightReMutex 0 4 247 26 LightReMutex::LightReMutex 0 2 101 102 1155
// Filename: lightReMutex.I
// Created by:  drose (08Oct08)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: LightReMutex::Constructor
//       Access: Public
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: LightReMutex::Constructor
//       Access: Public
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: LightReMutex::Constructor
//       Access: Public
//  Description:
////////////////////////////////////////////////////////////////////
109
inline LightReMutex::LightReMutex(void);
inline LightReMutex::LightReMutex(basic_string< char > const &name);

217 13 ~LightReMutex 0 4 247 27 LightReMutex::~LightReMutex 0 0 220
////////////////////////////////////////////////////////////////////
//     Function: LightReMutex::Destructor
//       Access: Public
//  Description:
////////////////////////////////////////////////////////////////////
41
inline LightReMutex::~LightReMutex(void);

218 14 get_class_type 0 4 248 26 MainThread::get_class_type 0 1 103 0
51
static TypeHandle MainThread::get_class_type(void);

219 11 ~MainThread 0 4 248 23 MainThread::~MainThread 0 0 0
30
MainThread::~MainThread(void);

220 12 PythonThread 0 4 249 26 PythonThread::PythonThread 0 1 104 224
////////////////////////////////////////////////////////////////////
//     Function: PythonThread::Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
136
PythonThread::PythonThread(PyObject *function, PyObject *args, basic_string< char > const &name, basic_string< char > const &sync_name);

221 4 join 0 4 249 18 PythonThread::join 0 1 105 506
////////////////////////////////////////////////////////////////////
//     Function: PythonThread::join
//       Access: Published
//  Description: Blocks the calling process until the thread
//               terminates.  If the thread has already terminated,
//               this returns immediately.
//
//               The PythonThread flavor of this function returns the
//               same value returned by the thread function.
////////////////////////////////////////////////////////////////////
35
PyObject *PythonThread::join(void);

222 14 get_class_type 0 4 249 28 PythonThread::get_class_type 0 1 106 0
53
static TypeHandle PythonThread::get_class_type(void);

223 9 Semaphore 0 4 250 20 Semaphore::Semaphore 0 2 107 108 969
// Filename: psemaphore.I
// Created by:  drose (13Oct08)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: Semaphore::Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: Semaphore::Copy Constructor
//       Access: Private
//  Description: Do not attempt to copy semaphores.
////////////////////////////////////////////////////////////////////
53
inline Semaphore::Semaphore(int initial_count = (1));

224 10 ~Semaphore 0 4 250 21 Semaphore::~Semaphore 0 0 221
////////////////////////////////////////////////////////////////////
//     Function: Semaphore::Destructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
35
inline Semaphore::~Semaphore(void);

225 7 acquire 0 4 250 18 Semaphore::acquire 0 1 109 372
////////////////////////////////////////////////////////////////////
//     Function: Semaphore::acquire
//       Access: Published
//  Description: Decrements the internal count.  If the count was
//               already at zero, blocks until the count is nonzero,
//               then decrements it.
////////////////////////////////////////////////////////////////////
37
inline void Semaphore::acquire(void);

226 11 try_acquire 0 4 250 22 Semaphore::try_acquire 0 1 110 342
////////////////////////////////////////////////////////////////////
//     Function: Semaphore::try_acquire
//       Access: Published
//  Description: If the semaphore can be acquired without blocking,
//               does so and returns true.  Otherwise, returns false.
////////////////////////////////////////////////////////////////////
41
inline bool Semaphore::try_acquire(void);

227 7 release 0 4 250 18 Semaphore::release 0 1 111 401
////////////////////////////////////////////////////////////////////
//     Function: Semaphore::release
//       Access: Published
//  Description: Increments the semaphore's internal count.  This may
//               wake up another thread blocked on acquire().
//
//               Returns the count of the semaphore upon release.
////////////////////////////////////////////////////////////////////
36
inline int Semaphore::release(void);

228 9 get_count 0 4 250 20 Semaphore::get_count 0 1 112 366
////////////////////////////////////////////////////////////////////
//     Function: Semaphore::get_count
//       Access: Published
//  Description: Returns the current semaphore count.  Note that this
//               call is not thread-safe (the count may change at any
//               time).
////////////////////////////////////////////////////////////////////
44
inline int Semaphore::get_count(void) const;

229 6 output 0 4 250 17 Semaphore::output 0 1 113 217
////////////////////////////////////////////////////////////////////
//     Function: Semaphore::output
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
43
void Semaphore::output(ostream &out) const;

113
1 14 Dtool_kd_idS4g 0 7 9 252 0 14 Dtool_kd_idS4g 0 0 
2 14 Dtool_kd_ikBIS 0 7 3 254 0 14 Dtool_kd_ikBIS 0 1 4 this 3 253  
3 14 Dtool_kd_i_Yr4 0 7 4 253 118 14 Dtool_kd_i_Yr4 0 1 4 this 3 254  
4 14 Dtool_kd_iqPoC 0 6 6 255 0 14 Dtool_kd_iqPoC 0 1 4 this 3 253  
5 14 Dtool_kd_iUoYV 0 7 7 253 118 14 Dtool_kd_iUoYV 0 1 4 this 3 255  
6 14 Dtool_kd_iRc6P 0 7 17 257 124 14 Dtool_kd_iRc6P 1438 ////////////////////////////////////////////////////////////////////
//     Function: Thread::bind_thread
//       Access: Published, Static
//  Description: Returns a new Panda Thread object associated with the
//               current thread (which has been created externally).
//               This can be used to bind a unique Panda Thread object
//               with an external thread, such as a new Python thread.
//
//               It is particularly useful to bind a Panda Thread
//               object to an external thread for the purposes of
//               PStats monitoring.  Without this call, each external
//               thread will be assigned the same global
//               ExternalThread object, which means they will all
//               appear in the same PStats graph.
//
//               It is the caller's responsibility to save the
//               returned Thread pointer for the lifetime of the
//               external thread.  It is an error for the Thread
//               pointer to destruct while the external thread is
//               still in the system.
//
//               It is also an error to call this method from the main
//               thread, or twice within a given thread, unless it is
//               given the same name each time (in which case the same
//               pointer will be returned each time).
//////////////////////////////////////////////////////////////////// 2 4 name 1 256  9 sync_name 1 256  
7 14 Dtool_kd_ijq87 0 6 18 256 0 14 Dtool_kd_ijq87 565 ////////////////////////////////////////////////////////////////////
//     Function: Thread::get_sync_name
//       Access: Published
//  Description: Returns the sync name of the thread.  This name
//               collects threads into "sync groups", which are
//               expected to run synchronously.  This is mainly used
//               for the benefit of PStats; threads with the same sync
//               name can be ticked all at once via the thread_tick()
//               call.
//////////////////////////////////////////////////////////////////// 1 4 this 3 258  
8 14 Dtool_kd_iH7ri 0 6 19 260 0 14 Dtool_kd_iH7ri 476 ////////////////////////////////////////////////////////////////////
//     Function: Thread::get_pstats_index
//       Access: Published
//  Description: Returns the PStats index associated with this thread,
//               or -1 if no index has yet been associated with this
//               thread.  This is used internally by the PStatClient;
//               you should not need to call this directly.
//////////////////////////////////////////////////////////////////// 1 4 this 3 258  
9 14 Dtool_kd_igw2i 0 6 20 256 0 14 Dtool_kd_igw2i 402 ////////////////////////////////////////////////////////////////////
//     Function: Thread::get_unique_id
//       Access: Published
//  Description: Returns a string that is guaranteed to be unique to
//               this thread, across all processes on the machine,
//               during at least the lifetime of this process.
//////////////////////////////////////////////////////////////////// 1 4 this 3 258  
10 14 Dtool_kd_imKhn 0 6 21 260 0 14 Dtool_kd_imKhn 409 ////////////////////////////////////////////////////////////////////
//     Function: Thread::get_pipeline_stage
//       Access: Published
//  Description: Returns the Pipeline stage number associated with
//               this thread.  The default stage is 0 if no stage is
//               specified otherwise.  See set_pipeline_stage().
//////////////////////////////////////////////////////////////////// 1 4 this 3 258  
11 14 Dtool_kd_iiVSW 0 4 22 261 0 14 Dtool_kd_iiVSW 831 ////////////////////////////////////////////////////////////////////
//     Function: Thread::set_pipeline_stage
//       Access: Published
//  Description: Specifies the Pipeline stage number associated with
//               this thread.  The default stage is 0 if no stage is
//               specified otherwise.
//
//               This must be a value in the range [0
//               .. pipeline->get_num_stages() - 1].  It specifies the
//               values that this thread observes for all pipelined
//               data.  Typically, an application thread will leave
//               this at 0, but a render thread may set it to 1 or 2
//               (to operate on the previous frame's data, or the
//               second previous frame's data).
//////////////////////////////////////////////////////////////////// 2 4 this 3 257  14 pipeline_stage 1 260  
12 14 Dtool_kd_iOmlk 0 4 23 261 0 14 Dtool_kd_iOmlk 392 ////////////////////////////////////////////////////////////////////
//     Function: Thread::set_min_pipeline_stage
//       Access: Published
//  Description: Sets this thread's pipeline stage number to at least
//               the indicated value, unless it is already larger.
//               See set_pipeline_stage().
//////////////////////////////////////////////////////////////////// 2 4 this 3 257  18 min_pipeline_stage 1 260  
13 14 Dtool_kd_iY2Dw 0 7 24 257 124 14 Dtool_kd_iY2Dw 345 ////////////////////////////////////////////////////////////////////
//     Function: Thread::get_main_thread
//       Access: Published, Static
//  Description: Returns a pointer to the "main" Thread object--this
//               is the Thread that started the whole process.
//////////////////////////////////////////////////////////////////// 0 
14 14 Dtool_kd_iD1UC 0 7 25 257 124 14 Dtool_kd_iD1UC 531 ////////////////////////////////////////////////////////////////////
//     Function: Thread::get_external_thread
//       Access: Published, Static
//  Description: Returns a pointer to the "external" Thread
//               object--this is a special Thread object that
//               corresponds to any thread spawned outside of Panda's
//               threading interface.  Note that multiple different
//               threads may share this same pointer.
//////////////////////////////////////////////////////////////////// 0 
15 14 Dtool_kd_i3TiV 0 7 26 257 124 14 Dtool_kd_i3TiV 738 ////////////////////////////////////////////////////////////////////
//     Function: Thread::get_current_thread
//       Access: Published, Static
//  Description: Returns a pointer to the currently-executing Thread
//               object.  If this is called from the main thread, this
//               will return the same value as get_main_thread().
//
//               This will always return some valid Thread pointer.
//               It will never return NULL, even if the current thread
//               was spawned outside of Panda's threading system,
//               although all non-Panda threads will return the exact
//               same Thread pointer.
//////////////////////////////////////////////////////////////////// 0 
16 14 Dtool_kd_iqF2R 0 6 27 260 0 14 Dtool_kd_iqF2R 485 ////////////////////////////////////////////////////////////////////
//     Function: Thread::get_current_pipeline_stage
//       Access: Published, Static
//  Description: Returns the integer pipeline stage associated with
//               the current thread.  This is the same thing as
//               get_current_thread()->get_pipeline_stage(), but it
//               may be faster to retrieve in some contexts.
//////////////////////////////////////////////////////////////////// 0 
17 14 Dtool_kd_i5vLQ 0 6 28 262 0 14 Dtool_kd_i5vLQ 417 ////////////////////////////////////////////////////////////////////
//     Function: Thread::is_threading_supported
//       Access: Published, Static
//  Description: Returns true if threading support has been compiled
//               in and enabled, or false if no threading is available
//               (and Thread::start() will always fail).
//////////////////////////////////////////////////////////////////// 0 
18 14 Dtool_kd_iyg5j 0 6 29 262 0 14 Dtool_kd_iyg5j 461 ////////////////////////////////////////////////////////////////////
//     Function: Thread::is_true_threads
//       Access: Published, Static
//  Description: Returns true if a real threading library is available
//               that supports actual OS-implemented threads, or false
//               if the only threading we can provide is simulated
//               user-space threading.
//////////////////////////////////////////////////////////////////// 0 
19 14 Dtool_kd_iQd5Y 0 6 30 262 0 14 Dtool_kd_iQd5Y 722 ////////////////////////////////////////////////////////////////////
//     Function: Thread::is_simple_threads
//       Access: Published, Static
//  Description: Returns true if Panda is currently compiled for
//               "simple threads", which is to say, cooperative
//               context switching only, reducing the need for quite
//               so many critical section protections.  This is not
//               necessarily the opposite of "true threads", since one
//               possible implementation of simple threads is via true
//               threads with mutex protection to ensure only one runs
//               at a time.
//////////////////////////////////////////////////////////////////// 0 
20 14 Dtool_kd_iEK72 0 4 31 261 0 14 Dtool_kd_iEK72 360 ////////////////////////////////////////////////////////////////////
//     Function: Thread::sleep
//       Access: Published, Static
//  Description: Suspends the current thread for at least the
//               indicated amount of time.  It might be suspended for
//               longer.
//////////////////////////////////////////////////////////////////// 1 7 seconds 1 263  
21 14 Dtool_kd_iA_Rs 0 4 32 261 0 14 Dtool_kd_iA_Rs 306 ////////////////////////////////////////////////////////////////////
//     Function: Thread::field_yield
//       Access: Published, Static
//  Description: Suspends the current thread for the rest of the
//               current epoch.
//////////////////////////////////////////////////////////////////// 0 
22 14 Dtool_kd_iMrcC 0 4 33 261 0 14 Dtool_kd_iMrcC 520 ////////////////////////////////////////////////////////////////////
//     Function: Thread::consider_yield
//       Access: Published, Static
//  Description: Possibly suspends the current thread for the rest of
//               the current epoch, if it has run for enough this
//               epoch.  This is especially important for the simple
//               thread implementation, which relies on cooperative
//               yields like this.
//////////////////////////////////////////////////////////////////// 0 
23 14 Dtool_kd_iffd4 0 4 34 261 0 14 Dtool_kd_iffd4 222 ////////////////////////////////////////////////////////////////////
//     Function: Thread::output
//       Access: Published, Virtual
//  Description:
//////////////////////////////////////////////////////////////////// 2 4 this 3 258  3 out 1 264  
24 14 Dtool_kd_iIMot 0 4 35 261 0 14 Dtool_kd_iIMot 440 ////////////////////////////////////////////////////////////////////
//     Function: Thread::output_blocker
//       Access: Published
//  Description: Writes a description of the mutex or condition
//               variable that this thread is blocked on.  Writes
//               nothing if there is no blocker, or if we are not in
//               DEBUG_THREADS mode.
//////////////////////////////////////////////////////////////////// 2 4 this 3 258  3 out 1 264  
25 14 Dtool_kd_iTfGZ 0 4 36 261 0 14 Dtool_kd_iTfGZ 227 ////////////////////////////////////////////////////////////////////
//     Function: Thread::write_status
//       Access: Published, Static
//  Description:
//////////////////////////////////////////////////////////////////// 1 3 out 1 264  
26 14 Dtool_kd_i9pHH 0 6 37 262 0 14 Dtool_kd_i9pHH 338 ////////////////////////////////////////////////////////////////////
//     Function: Thread::is_started
//       Access: Published
//  Description: Returns true if the thread has been started, false if
//               it has not, or if join() has already been called.
//////////////////////////////////////////////////////////////////// 1 4 this 3 258  
27 14 Dtool_kd_ifYmX 0 6 38 262 0 14 Dtool_kd_ifYmX 302 ////////////////////////////////////////////////////////////////////
//     Function: Thread::is_joinable
//       Access: Published
//  Description: Returns the value of joinable that was passed to the
//               start() call.
//////////////////////////////////////////////////////////////////// 1 4 this 3 258  
28 14 Dtool_kd_i6vf2 0 6 39 262 0 14 Dtool_kd_i6vf2 1333 ////////////////////////////////////////////////////////////////////
//     Function: Thread::start
//       Access: Public
//  Description: Starts the thread executing.  It is only valid to
//               call this once.
//
//               The thread will begin executing its thread_main()
//               function, and will terminate when thread_main()
//               returns.
//
//               priority is intended as a hint to the relative
//               importance of this thread.  This may be ignored by
//               the thread implementation.
//
//               joinable should be set true if you intend to call
//               join() to wait for the thread to terminate, or false
//               if you don't care and you will never call join().
//               Note that the reference count on the Thread object is
//               incremented while the thread itself is running, so if
//               you just want to fire and forget a thread, you may
//               pass joinable = false, and never store the Thread
//               object.  It will automatically destruct itself when
//               it finishes.
//
//               The return value is true if the thread is
//               successfully started, false otherwise.
//////////////////////////////////////////////////////////////////// 3 4 this 3 257  8 priority 1 233  8 joinable 1 262  
29 14 Dtool_kd_iz6lV 0 4 40 261 0 14 Dtool_kd_iz6lV 366 ////////////////////////////////////////////////////////////////////
//     Function: Thread::join
//       Access: Published
//  Description: Blocks the calling process until the thread
//               terminates.  If the thread has already terminated,
//               this returns immediately.
//////////////////////////////////////////////////////////////////// 1 4 this 3 257  
30 14 Dtool_kd_iEmqG 0 4 41 261 0 14 Dtool_kd_iEmqG 432 ////////////////////////////////////////////////////////////////////
//     Function: Thread::preempt
//       Access: Published
//  Description: Indicates that this thread should run as soon as
//               possible, preemptying any other threads that may be
//               scheduled to run.  This may not be implemented on
//               every platform.
//////////////////////////////////////////////////////////////////// 1 4 this 3 257  
31 14 Dtool_kd_iBnhA 0 4 42 261 0 14 Dtool_kd_iBnhA 543 ////////////////////////////////////////////////////////////////////
//     Function: Thread::set_python_data
//       Access: Published
//  Description: Sets an arbitrary Python object that may be
//               associated with this thread object.  This is just for
//               the purposes of associated arbitrary Python data with
//               the C++ object; other than managing the reference
//               count, the C++ code does nothing with this object.
//////////////////////////////////////////////////////////////////// 2 4 this 3 257  11 python_data 1 266  
32 14 Dtool_kd_i3PGe 0 6 43 266 0 14 Dtool_kd_i3PGe 302 ////////////////////////////////////////////////////////////////////
//     Function: Thread::get_python_data
//       Access: Published
//  Description: Returns the Python object that was set with
//               set_python_data().
//////////////////////////////////////////////////////////////////// 1 4 this 3 258  
33 14 Dtool_kd_iHhFW 0 7 44 253 118 14 Dtool_kd_iHhFW 402 ////////////////////////////////////////////////////////////////////
//     Function: Thread::get_current_task
//       Access: Published
//  Description: Returns the task currently executing on this thread
//               (via the AsyncTaskManager), if any, or NULL if the
//               thread is not currently servicing a task.
//////////////////////////////////////////////////////////////////// 1 4 this 3 258  
34 14 Dtool_kd_iwYwm 0 4 45 261 0 14 Dtool_kd_iwYwm 387 ////////////////////////////////////////////////////////////////////
//     Function: Thread::prepare_for_exit
//       Access: Published
//  Description: Should be called by the main thread just before
//               exiting the program, this blocks until any remaining
//               thread cleanup has finished.
//////////////////////////////////////////////////////////////////// 0 
35 14 Dtool_kd_i_lqM 0 7 46 252 0 14 Dtool_kd_i_lqM 0 0 
36 14 Dtool_kd_im7Dx 0 7 12 254 0 14 Dtool_kd_im7Dx 0 1 4 this 3 257  
37 14 Dtool_kd_iiO2P 0 7 13 257 124 14 Dtool_kd_iiO2P 0 1 4 this 3 254  
38 14 Dtool_kd_ilnUX 0 6 14 255 0 14 Dtool_kd_ilnUX 0 1 4 this 3 257  
39 14 Dtool_kd_iFtoz 0 7 15 257 124 14 Dtool_kd_iFtoz 0 1 4 this 3 255  
40 14 Dtool_kd_iOui6 0 4 48 261 0 14 Dtool_kd_iOui6 735 ////////////////////////////////////////////////////////////////////
//     Function: MutexDirect::acquire
//       Access: Published
//  Description: Grabs the mutex if it is available.  If it is not
//               available, blocks until it becomes available, then
//               grabs it.  In either case, the function does not
//               return until the mutex is held; you should then call
//               unlock().
//
//               This method is considered const so that you can lock
//               and unlock const mutexes, mainly to allow thread-safe
//               access to otherwise const data.
//
//               Also see MutexHolder.
//////////////////////////////////////////////////////////////////// 1 4 this 3 268  
41 14 Dtool_kd_ia7c4 0 6 49 262 0 14 Dtool_kd_ia7c4 369 ////////////////////////////////////////////////////////////////////
//     Function: MutexDirect::try_acquire
//       Access: Published
//  Description: Returns immediately, with a true value indicating the
//               mutex has been acquired, and false indicating it has
//               not.
//////////////////////////////////////////////////////////////////// 1 4 this 3 268  
42 14 Dtool_kd_ippbs 0 4 50 261 0 14 Dtool_kd_ippbs 515 ////////////////////////////////////////////////////////////////////
//     Function: MutexDirect::release
//       Access: Published
//  Description: Releases the mutex.  It is an error to call this if
//               the mutex was not already locked.
//
//               This method is considered const so that you can lock
//               and unlock const mutexes, mainly to allow thread-safe
//               access to otherwise const data.
//////////////////////////////////////////////////////////////////// 1 4 this 3 268  
43 14 Dtool_kd_iHTyM 0 6 51 262 0 14 Dtool_kd_iHTyM 572 ////////////////////////////////////////////////////////////////////
//     Function: MutexDirect::debug_is_locked
//       Access: Published
//  Description: Returns true if the current thread has locked the
//               Mutex, false otherwise.  This method is only intended
//               for use in debugging, hence the method name; in the
//               MutexDirect case, it always returns true, since
//               there's not a reliable way to determine this
//               otherwise.
//////////////////////////////////////////////////////////////////// 1 4 this 3 268  
44 14 Dtool_kd_i9_B4 0 4 52 261 0 14 Dtool_kd_i9_B4 303 ////////////////////////////////////////////////////////////////////
//     Function: MutexDirect::set_name
//       Access: Public
//  Description: The mutex name is only defined when compiling in
//               DEBUG_THREADS mode.
//////////////////////////////////////////////////////////////////// 2 4 this 3 270  4 name 1 256  
45 14 Dtool_kd_iJnDd 0 4 53 261 0 14 Dtool_kd_iJnDd 305 ////////////////////////////////////////////////////////////////////
//     Function: MutexDirect::clear_name
//       Access: Public
//  Description: The mutex name is only defined when compiling in
//               DEBUG_THREADS mode.
//////////////////////////////////////////////////////////////////// 1 4 this 3 270  
46 14 Dtool_kd_iqC3W 0 6 54 262 0 14 Dtool_kd_iqC3W 303 ////////////////////////////////////////////////////////////////////
//     Function: MutexDirect::has_name
//       Access: Public
//  Description: The mutex name is only defined when compiling in
//               DEBUG_THREADS mode.
//////////////////////////////////////////////////////////////////// 1 4 this 3 268  
47 14 Dtool_kd_iAGiT 0 6 55 256 0 14 Dtool_kd_iAGiT 303 ////////////////////////////////////////////////////////////////////
//     Function: MutexDirect::get_name
//       Access: Public
//  Description: The mutex name is only defined when compiling in
//               DEBUG_THREADS mode.
//////////////////////////////////////////////////////////////////// 1 4 this 3 268  
48 14 Dtool_kd_iyEWt 0 4 56 261 0 14 Dtool_kd_iyEWt 311 ////////////////////////////////////////////////////////////////////
//     Function: MutexDirect::output
//       Access: Public
//  Description: This method is declared virtual in MutexDebug, but
//               non-virtual in MutexDirect.
//////////////////////////////////////////////////////////////////// 2 4 this 3 268  3 out 1 264  
49 14 Dtool_kd_iNvQQ 0 7 58 271 165 14 Dtool_kd_iNvQQ 699 // Filename: pmutex.I
// Created by:  drose (08Aug02)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: Mutex::Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 0 
50 14 Dtool_kd_idp7X 0 7 58 271 165 14 Dtool_kd_idp7X 217 ////////////////////////////////////////////////////////////////////
//     Function: Mutex::Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 name 1 256  
51 14 Dtool_kd_iD016 0 6 62 270 0 14 Dtool_kd_iD016 301 ////////////////////////////////////////////////////////////////////
//     Function: ConditionVarDirect::get_mutex
//       Access: Public
//  Description: Returns the mutex associated with this condition
//               variable.
//////////////////////////////////////////////////////////////////// 1 4 this 3 272  
52 14 Dtool_kd_iG44v 0 4 63 261 0 14 Dtool_kd_iG44v 1330 ////////////////////////////////////////////////////////////////////
//     Function: ConditionVarDirect::wait
//       Access: Public
//  Description: Waits on the condition.  The caller must already be
//               holding the lock associated with the condition
//               variable before calling this function.
//
//               wait() will release the lock, then go to sleep until
//               some other thread calls notify() on this condition
//               variable.  At that time at least one thread waiting
//               on the same ConditionVarDirect will grab the lock again,
//               and then return from wait().
//
//               It is possible that wait() will return even if no one
//               has called notify().  It is the responsibility of the
//               calling process to verify the condition on return
//               from wait, and possibly loop back to wait again if
//               necessary.
//
//               Note the semantics of a condition variable: the mutex
//               must be held before wait() is called, and it will
//               still be held when wait() returns.  However, it will
//               be temporarily released during the wait() call
//               itself.
//////////////////////////////////////////////////////////////////// 1 4 this 3 274  
53 14 Dtool_kd_i2oja 0 4 63 261 0 14 Dtool_kd_i2oja 613 ////////////////////////////////////////////////////////////////////
//     Function: ConditionVarDirect::wait
//       Access: Published
//  Description: Waits on the condition, with a timeout.  The function
//               will return when the condition variable is notified,
//               or the timeout occurs.  There is no way to directly
//               tell which happened, and it is possible that neither
//               in fact happened (spurious wakeups are possible).
//
//               See wait() with no parameters for more.
//////////////////////////////////////////////////////////////////// 2 4 this 3 274  7 timeout 1 263  
54 14 Dtool_kd_ilhob 0 4 64 261 0 14 Dtool_kd_ilhob 903 ////////////////////////////////////////////////////////////////////
//     Function: ConditionVarDirect::notify
//       Access: Public
//  Description: Informs one of the other threads who are currently
//               blocked on wait() that the relevant condition has
//               changed.  If multiple threads are currently waiting,
//               at least one of them will be woken up, although there
//               is no way to predict which one.  It is possible that
//               more than one thread will be woken up.
//
//               The caller must be holding the mutex associated with
//               the condition variable before making this call, which
//               will not release the mutex.
//
//               If no threads are waiting, this is a no-op: the
//               notify event is lost.
//////////////////////////////////////////////////////////////////// 1 4 this 3 274  
55 14 Dtool_kd_i_ndm 0 4 65 261 0 14 Dtool_kd_i_ndm 332 ////////////////////////////////////////////////////////////////////
//     Function: ConditionVarDirect::output
//       Access: Public
//  Description: This method is declared virtual in ConditionVarDebug,
//               but non-virtual in ConditionVarDirect.
//////////////////////////////////////////////////////////////////// 2 4 this 3 272  3 out 1 264  
56 14 Dtool_kd_iYPq5 0 7 67 275 172 14 Dtool_kd_iYPq5 1056 // Filename: conditionVar.I
// Created by:  drose (09Aug02)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: ConditionVar::Constructor
//       Access: Published
//  Description: You must pass in a Mutex to the condition variable
//               constructor.  This mutex may be shared by other
//               condition variables, if desired.  It is the caller's
//               responsibility to ensure the Mutex object does not
//               destruct during the lifetime of the condition
//               variable.
//////////////////////////////////////////////////////////////////// 1 5 mutex 1 271  
57 14 Dtool_kd_iVf1V 0 6 69 271 0 14 Dtool_kd_iVf1V 298 ////////////////////////////////////////////////////////////////////
//     Function: ConditionVar::get_mutex
//       Access: Published
//  Description: Returns the mutex associated with this condition
//               variable.
//////////////////////////////////////////////////////////////////// 1 4 this 3 276  
58 14 Dtool_kd_ij3dq 0 6 72 270 0 14 Dtool_kd_ij3dq 308 ////////////////////////////////////////////////////////////////////
//     Function: ConditionVarFullDirect::get_mutex
//       Access: Published
//  Description: Returns the mutex associated with this condition
//               variable.
//////////////////////////////////////////////////////////////////// 1 4 this 3 278  
59 14 Dtool_kd_iqoyJ 0 4 73 261 0 14 Dtool_kd_iqoyJ 1341 ////////////////////////////////////////////////////////////////////
//     Function: ConditionVarFullDirect::wait
//       Access: Published
//  Description: Waits on the condition.  The caller must already be
//               holding the lock associated with the condition
//               variable before calling this function.
//
//               wait() will release the lock, then go to sleep until
//               some other thread calls notify() on this condition
//               variable.  At that time at least one thread waiting
//               on the same ConditionVarFullDirect will grab the lock again,
//               and then return from wait().
//
//               It is possible that wait() will return even if no one
//               has called notify().  It is the responsibility of the
//               calling process to verify the condition on return
//               from wait, and possibly loop back to wait again if
//               necessary.
//
//               Note the semantics of a condition variable: the mutex
//               must be held before wait() is called, and it will
//               still be held when wait() returns.  However, it will
//               be temporarily released during the wait() call
//               itself.
//////////////////////////////////////////////////////////////////// 1 4 this 3 280  
60 14 Dtool_kd_i20dk 0 4 73 261 0 14 Dtool_kd_i20dk 617 ////////////////////////////////////////////////////////////////////
//     Function: ConditionVarFullDirect::wait
//       Access: Published
//  Description: Waits on the condition, with a timeout.  The function
//               will return when the condition variable is notified,
//               or the timeout occurs.  There is no way to directly
//               tell which happened, and it is possible that neither
//               in fact happened (spurious wakeups are possible).
//
//               See wait() with no parameters for more.
//////////////////////////////////////////////////////////////////// 2 4 this 3 280  7 timeout 1 263  
61 14 Dtool_kd_iqZiM 0 4 74 261 0 14 Dtool_kd_iqZiM 904 ////////////////////////////////////////////////////////////////////
//     Function: ConditionVarFullDirect::notify
//       Access: Published
//  Description: Informs one of the other threads who are currently
//               blocked on wait() that the relevant condition has
//               changed.  If multiple threads are currently waiting,
//               at least one of them will be woken up, although there
//               is no way to predict which one.  It is possible that
//               more than one thread will be woken up.
//
//               The caller must be holding the mutex associated with
//               the condition variable before making this call, which
//               will not release the mutex.
//
//               If no threads are waiting, this is a no-op: the
//               notify is lost.
//////////////////////////////////////////////////////////////////// 1 4 this 3 280  
62 14 Dtool_kd_iDEGf 0 4 75 261 0 14 Dtool_kd_iDEGf 673 ////////////////////////////////////////////////////////////////////
//     Function: ConditionVarFullDirect::notify_all
//       Access: Published
//  Description: Informs all of the other threads who are currently
//               blocked on wait() that the relevant condition has
//               changed.
//
//               The caller must be holding the mutex associated with
//               the condition variable before making this call, which
//               will not release the mutex.
//
//               If no threads are waiting, this is a no-op: the
//               notify event is lost.
//////////////////////////////////////////////////////////////////// 1 4 this 3 280  
63 14 Dtool_kd_ipZKZ 0 4 76 261 0 14 Dtool_kd_ipZKZ 344 ////////////////////////////////////////////////////////////////////
//     Function: ConditionVarFullDirect::output
//       Access: Public
//  Description: This method is declared virtual in ConditionVarFullDebug,
//               but non-virtual in ConditionVarFullDirect.
//////////////////////////////////////////////////////////////////// 2 4 this 3 278  3 out 1 264  
64 14 Dtool_kd_i7JQC 0 7 78 281 181 14 Dtool_kd_i7JQC 1064 // Filename: conditionVarFull.I
// Created by:  drose (28Aug06)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: ConditionVarFull::Constructor
//       Access: Published
//  Description: You must pass in a Mutex to the condition variable
//               constructor.  This mutex may be shared by other
//               condition variables, if desired.  It is the caller's
//               responsibility to ensure the Mutex object does not
//               destruct during the lifetime of the condition
//               variable.
//////////////////////////////////////////////////////////////////// 1 5 mutex 1 271  
65 14 Dtool_kd_iHhKo 0 6 80 271 0 14 Dtool_kd_iHhKo 302 ////////////////////////////////////////////////////////////////////
//     Function: ConditionVarFull::get_mutex
//       Access: Published
//  Description: Returns the mutex associated with this condition
//               variable.
//////////////////////////////////////////////////////////////////// 1 4 this 3 282  
66 14 Dtool_kd_it6SB 0 4 82 261 0 14 Dtool_kd_it6SB 745 ////////////////////////////////////////////////////////////////////
//     Function: ReMutexDirect::acquire
//       Access: Published
//  Description: Grabs the reMutex if it is available.  If it is not
//               available, blocks until it becomes available, then
//               grabs it.  In either case, the function does not
//               return until the reMutex is held; you should then call
//               unlock().
//
//               This method is considered const so that you can lock
//               and unlock const reMutexes, mainly to allow thread-safe
//               access to otherwise const data.
//
//               Also see ReMutexHolder.
//////////////////////////////////////////////////////////////////// 1 4 this 3 284  
67 14 Dtool_kd_iUbPW 0 4 82 261 0 14 Dtool_kd_iUbPW 368 ////////////////////////////////////////////////////////////////////
//     Function: ReMutexDirect::acquire
//       Access: Published
//  Description: This variant on acquire() accepts the current thread as
//               a parameter, if it is already known, as an
//               optimization.
//////////////////////////////////////////////////////////////////// 2 4 this 3 284  14 current_thread 1 257  
68 14 Dtool_kd_irrov 0 6 83 262 0 14 Dtool_kd_irrov 371 ////////////////////////////////////////////////////////////////////
//     Function: ReMutexDirect::try_acquire
//       Access: Published
//  Description: Returns immediately, with a true value indicating the
//               mutex has been acquired, and false indicating it has
//               not.
//////////////////////////////////////////////////////////////////// 1 4 this 3 284  
69 14 Dtool_kd_iOL6E 0 6 83 262 0 14 Dtool_kd_iOL6E 371 ////////////////////////////////////////////////////////////////////
//     Function: ReMutexDirect::try_acquire
//       Access: Published
//  Description: Returns immediately, with a true value indicating the
//               mutex has been acquired, and false indicating it has
//               not.
//////////////////////////////////////////////////////////////////// 2 4 this 3 284  14 current_thread 1 257  
70 14 Dtool_kd_ipqNB 0 4 84 261 0 14 Dtool_kd_ipqNB 819 ////////////////////////////////////////////////////////////////////
//     Function: ReMutexDirect::elevate_lock
//       Access: Published
//  Description: This method increments the lock count, assuming the
//               calling thread already holds the lock.  After this
//               call, release() will need to be called one additional
//               time to release the lock.
//
//               This method really performs the same function as
//               acquire(), but it offers a potential (slight)
//               performance benefit when the calling thread knows
//               that it already holds the lock.  It is an error to
//               call this when the calling thread does not hold the
//               lock.
//////////////////////////////////////////////////////////////////// 1 4 this 3 284  
71 14 Dtool_kd_iKHzQ 0 4 85 261 0 14 Dtool_kd_iKHzQ 523 ////////////////////////////////////////////////////////////////////
//     Function: ReMutexDirect::release
//       Access: Published
//  Description: Releases the reMutex.  It is an error to call this if
//               the reMutex was not already locked.
//
//               This method is considered const so that you can lock
//               and unlock const reMutexes, mainly to allow thread-safe
//               access to otherwise const data.
//////////////////////////////////////////////////////////////////// 1 4 this 3 284  
72 14 Dtool_kd_i7UUZ 0 6 86 262 0 14 Dtool_kd_i7UUZ 578 ////////////////////////////////////////////////////////////////////
//     Function: ReMutexDirect::debug_is_locked
//       Access: Published
//  Description: Returns true if the current thread has locked the
//               ReMutex, false otherwise.  This method is only intended
//               for use in debugging, hence the method name; in the
//               ReMutexDirect case, it always returns true, since
//               there's not a reliable way to determine this
//               otherwise.
//////////////////////////////////////////////////////////////////// 1 4 this 3 284  
73 14 Dtool_kd_i_Nyn 0 4 87 261 0 14 Dtool_kd_i_Nyn 305 ////////////////////////////////////////////////////////////////////
//     Function: ReMutexDirect::set_name
//       Access: Public
//  Description: The mutex name is only defined when compiling in
//               DEBUG_THREADS mode.
//////////////////////////////////////////////////////////////////// 2 4 this 3 286  4 name 1 256  
74 14 Dtool_kd_ibDp3 0 4 88 261 0 14 Dtool_kd_ibDp3 307 ////////////////////////////////////////////////////////////////////
//     Function: ReMutexDirect::clear_name
//       Access: Public
//  Description: The mutex name is only defined when compiling in
//               DEBUG_THREADS mode.
//////////////////////////////////////////////////////////////////// 1 4 this 3 286  
75 14 Dtool_kd_iMADE 0 6 89 262 0 14 Dtool_kd_iMADE 305 ////////////////////////////////////////////////////////////////////
//     Function: ReMutexDirect::has_name
//       Access: Public
//  Description: The mutex name is only defined when compiling in
//               DEBUG_THREADS mode.
//////////////////////////////////////////////////////////////////// 1 4 this 3 284  
76 14 Dtool_kd_iCBpz 0 6 90 256 0 14 Dtool_kd_iCBpz 305 ////////////////////////////////////////////////////////////////////
//     Function: ReMutexDirect::get_name
//       Access: Public
//  Description: The mutex name is only defined when compiling in
//               DEBUG_THREADS mode.
//////////////////////////////////////////////////////////////////// 1 4 this 3 284  
77 14 Dtool_kd_iywef 0 4 91 261 0 14 Dtool_kd_iywef 318 ////////////////////////////////////////////////////////////////////
//     Function: ReMutexDirect::output
//       Access: Published
//  Description: This method is declared virtual in MutexDebug, but
//               non-virtual in ReMutexDirect.
//////////////////////////////////////////////////////////////////// 2 4 this 3 284  3 out 1 264  
78 14 Dtool_kd_iyZ9B 0 7 93 287 194 14 Dtool_kd_iyZ9B 699 // Filename: reMutex.I
// Created by:  drose (15Jan06)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: ReMutex::Constructor
//       Access: Public
//  Description:
//////////////////////////////////////////////////////////////////// 0 
79 14 Dtool_kd_irzYG 0 7 93 287 194 14 Dtool_kd_irzYG 216 ////////////////////////////////////////////////////////////////////
//     Function: ReMutex::Constructor
//       Access: Public
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 name 1 256  
80 14 Dtool_kd_iSmL_ 0 7 96 252 0 14 Dtool_kd_iSmL_ 0 0 
81 14 Dtool_kd_igIId 0 4 99 261 0 14 Dtool_kd_igIId 760 ////////////////////////////////////////////////////////////////////
//     Function: LightMutexDirect::acquire
//       Access: Published
//  Description: Grabs the lightMutex if it is available.  If it is not
//               available, blocks until it becomes available, then
//               grabs it.  In either case, the function does not
//               return until the lightMutex is held; you should then call
//               unlock().
//
//               This method is considered const so that you can lock
//               and unlock const lightMutexes, mainly to allow thread-safe
//               access to otherwise const data.
//
//               Also see LightMutexHolder.
//////////////////////////////////////////////////////////////////// 1 4 this 3 288  
82 14 Dtool_kd_iv86A 0 4 100 261 0 14 Dtool_kd_iv86A 535 ////////////////////////////////////////////////////////////////////
//     Function: LightMutexDirect::release
//       Access: Published
//  Description: Releases the lightMutex.  It is an error to call this if
//               the lightMutex was not already locked.
//
//               This method is considered const so that you can lock
//               and unlock const lightMutexes, mainly to allow thread-safe
//               access to otherwise const data.
//////////////////////////////////////////////////////////////////// 1 4 this 3 288  
83 14 Dtool_kd_isRoB 0 6 101 262 0 14 Dtool_kd_isRoB 587 ////////////////////////////////////////////////////////////////////
//     Function: LightMutexDirect::debug_is_locked
//       Access: Published
//  Description: Returns true if the current thread has locked the
//               LightMutex, false otherwise.  This method is only intended
//               for use in debugging, hence the method name; in the
//               LightMutexDirect case, it always returns true, since
//               there's not a reliable way to determine this
//               otherwise.
//////////////////////////////////////////////////////////////////// 1 4 this 3 288  
84 14 Dtool_kd_iMAKY 0 4 102 261 0 14 Dtool_kd_iMAKY 313 ////////////////////////////////////////////////////////////////////
//     Function: LightMutexDirect::set_name
//       Access: Public
//  Description: The lightMutex name is only defined when compiling in
//               DEBUG_THREADS mode.
//////////////////////////////////////////////////////////////////// 2 4 this 3 290  4 name 1 256  
85 14 Dtool_kd_i39Ii 0 4 103 261 0 14 Dtool_kd_i39Ii 315 ////////////////////////////////////////////////////////////////////
//     Function: LightMutexDirect::clear_name
//       Access: Public
//  Description: The lightMutex name is only defined when compiling in
//               DEBUG_THREADS mode.
//////////////////////////////////////////////////////////////////// 1 4 this 3 290  
86 14 Dtool_kd_ifUxV 0 6 104 262 0 14 Dtool_kd_ifUxV 313 ////////////////////////////////////////////////////////////////////
//     Function: LightMutexDirect::has_name
//       Access: Public
//  Description: The lightMutex name is only defined when compiling in
//               DEBUG_THREADS mode.
//////////////////////////////////////////////////////////////////// 1 4 this 3 288  
87 14 Dtool_kd_iPdHP 0 6 105 256 0 14 Dtool_kd_iPdHP 313 ////////////////////////////////////////////////////////////////////
//     Function: LightMutexDirect::get_name
//       Access: Public
//  Description: The lightMutex name is only defined when compiling in
//               DEBUG_THREADS mode.
//////////////////////////////////////////////////////////////////// 1 4 this 3 288  
88 14 Dtool_kd_i5WyC 0 4 106 261 0 14 Dtool_kd_i5WyC 326 ////////////////////////////////////////////////////////////////////
//     Function: LightMutexDirect::output
//       Access: Public
//  Description: This method is declared virtual in LightMutexDebug, but
//               non-virtual in LightMutexDirect.
//////////////////////////////////////////////////////////////////// 2 4 this 3 288  3 out 1 264  
89 14 Dtool_kd_iwke4 0 7 108 291 206 14 Dtool_kd_iwke4 708 // Filename: lightMutex.I
// Created by:  drose (08Oct08)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: LightMutex::Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 0 
90 14 Dtool_kd_iMnVX 0 7 108 291 206 14 Dtool_kd_iMnVX 222 ////////////////////////////////////////////////////////////////////
//     Function: LightMutex::Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 name 1 256  
91 14 Dtool_kd_ipFmq 0 4 111 261 0 14 Dtool_kd_ipFmq 770 ////////////////////////////////////////////////////////////////////
//     Function: LightReMutexDirect::acquire
//       Access: Published
//  Description: Grabs the lightReMutex if it is available.  If it is not
//               available, blocks until it becomes available, then
//               grabs it.  In either case, the function does not
//               return until the lightReMutex is held; you should then call
//               unlock().
//
//               This method is considered const so that you can lock
//               and unlock const lightReMutexes, mainly to allow thread-safe
//               access to otherwise const data.
//
//               Also see LightReMutexHolder.
//////////////////////////////////////////////////////////////////// 1 4 this 3 292  
92 14 Dtool_kd_iq5jU 0 4 111 261 0 14 Dtool_kd_iq5jU 373 ////////////////////////////////////////////////////////////////////
//     Function: LightReMutexDirect::acquire
//       Access: Published
//  Description: This variant on acquire() accepts the current thread as
//               a parameter, if it is already known, as an
//               optimization.
//////////////////////////////////////////////////////////////////// 2 4 this 3 292  14 current_thread 1 257  
93 14 Dtool_kd_iN2dq 0 4 112 261 0 14 Dtool_kd_iN2dq 824 ////////////////////////////////////////////////////////////////////
//     Function: LightReMutexDirect::elevate_lock
//       Access: Published
//  Description: This method increments the lock count, assuming the
//               calling thread already holds the lock.  After this
//               call, release() will need to be called one additional
//               time to release the lock.
//
//               This method really performs the same function as
//               acquire(), but it offers a potential (slight)
//               performance benefit when the calling thread knows
//               that it already holds the lock.  It is an error to
//               call this when the calling thread does not hold the
//               lock.
//////////////////////////////////////////////////////////////////// 1 4 this 3 292  
94 14 Dtool_kd_iqsmJ 0 4 113 261 0 14 Dtool_kd_iqsmJ 543 ////////////////////////////////////////////////////////////////////
//     Function: LightReMutexDirect::release
//       Access: Published
//  Description: Releases the lightReMutex.  It is an error to call this if
//               the lightReMutex was not already locked.
//
//               This method is considered const so that you can lock
//               and unlock const lightReMutexes, mainly to allow thread-safe
//               access to otherwise const data.
//////////////////////////////////////////////////////////////////// 1 4 this 3 292  
95 14 Dtool_kd_i9mua 0 6 114 262 0 14 Dtool_kd_i9mua 593 ////////////////////////////////////////////////////////////////////
//     Function: LightReMutexDirect::debug_is_locked
//       Access: Published
//  Description: Returns true if the current thread has locked the
//               LightReMutex, false otherwise.  This method is only intended
//               for use in debugging, hence the method name; in the
//               LightReMutexDirect case, it always returns true, since
//               there's not a reliable way to determine this
//               otherwise.
//////////////////////////////////////////////////////////////////// 1 4 this 3 292  
96 14 Dtool_kd_iVMm3 0 4 115 261 0 14 Dtool_kd_iVMm3 310 ////////////////////////////////////////////////////////////////////
//     Function: LightReMutexDirect::set_name
//       Access: Public
//  Description: The mutex name is only defined when compiling in
//               DEBUG_THREADS mode.
//////////////////////////////////////////////////////////////////// 2 4 this 3 294  4 name 1 256  
97 14 Dtool_kd_iSRSX 0 4 116 261 0 14 Dtool_kd_iSRSX 312 ////////////////////////////////////////////////////////////////////
//     Function: LightReMutexDirect::clear_name
//       Access: Public
//  Description: The mutex name is only defined when compiling in
//               DEBUG_THREADS mode.
//////////////////////////////////////////////////////////////////// 1 4 this 3 294  
98 14 Dtool_kd_iO1Hw 0 6 117 262 0 14 Dtool_kd_iO1Hw 310 ////////////////////////////////////////////////////////////////////
//     Function: LightReMutexDirect::has_name
//       Access: Public
//  Description: The mutex name is only defined when compiling in
//               DEBUG_THREADS mode.
//////////////////////////////////////////////////////////////////// 1 4 this 3 292  
99 14 Dtool_kd_iE3TP 0 6 118 256 0 14 Dtool_kd_iE3TP 310 ////////////////////////////////////////////////////////////////////
//     Function: LightReMutexDirect::get_name
//       Access: Public
//  Description: The mutex name is only defined when compiling in
//               DEBUG_THREADS mode.
//////////////////////////////////////////////////////////////////// 1 4 this 3 292  
100 14 Dtool_kd_iYWCn 0 4 119 261 0 14 Dtool_kd_iYWCn 328 ////////////////////////////////////////////////////////////////////
//     Function: LightReMutexDirect::output
//       Access: Published
//  Description: This method is declared virtual in MutexDebug, but
//               non-virtual in LightReMutexDirect.
//////////////////////////////////////////////////////////////////// 2 4 this 3 292  3 out 1 264  
101 14 Dtool_kd_idgTl 0 7 121 295 217 14 Dtool_kd_idgTl 709 // Filename: lightReMutex.I
// Created by:  drose (08Oct08)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: LightReMutex::Constructor
//       Access: Public
//  Description:
//////////////////////////////////////////////////////////////////// 0 
102 14 Dtool_kd_id1K3 0 7 121 295 217 14 Dtool_kd_id1K3 221 ////////////////////////////////////////////////////////////////////
//     Function: LightReMutex::Constructor
//       Access: Public
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 name 1 256  
103 14 Dtool_kd_iLWAo 0 7 124 252 0 14 Dtool_kd_iLWAo 0 0 
104 14 Dtool_kd_iwMgt 0 7 127 296 124 14 Dtool_kd_iwMgt 224 ////////////////////////////////////////////////////////////////////
//     Function: PythonThread::Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 4 8 function 1 266  4 args 1 266  4 name 1 256  9 sync_name 1 256  
105 14 Dtool_kd_iSXFP 0 6 128 266 0 14 Dtool_kd_iSXFP 506 ////////////////////////////////////////////////////////////////////
//     Function: PythonThread::join
//       Access: Published
//  Description: Blocks the calling process until the thread
//               terminates.  If the thread has already terminated,
//               this returns immediately.
//
//               The PythonThread flavor of this function returns the
//               same value returned by the thread function.
//////////////////////////////////////////////////////////////////// 1 4 this 3 296  
106 14 Dtool_kd_iKwfX 0 7 129 252 0 14 Dtool_kd_iKwfX 0 0 
107 14 Dtool_kd_iCIsB 0 7 131 297 224 14 Dtool_kd_iCIsB 708 // Filename: psemaphore.I
// Created by:  drose (13Oct08)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: Semaphore::Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 1 13 initial_count 1 260  
108 14 Dtool_kd_idG23 0 7 131 297 224 14 Dtool_kd_idG23 708 // Filename: psemaphore.I
// Created by:  drose (13Oct08)
//
////////////////////////////////////////////////////////////////////
//
// PANDA 3D SOFTWARE
// Copyright (c) Carnegie Mellon University.  All rights reserved.
//
// All use of this software is subject to the terms of the revised BSD
// license.  You should have received a copy of this license along
// with this source code in a file named "LICENSE."
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//     Function: Semaphore::Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 0 
109 14 Dtool_kd_iu2W_ 0 4 133 261 0 14 Dtool_kd_iu2W_ 372 ////////////////////////////////////////////////////////////////////
//     Function: Semaphore::acquire
//       Access: Published
//  Description: Decrements the internal count.  If the count was
//               already at zero, blocks until the count is nonzero,
//               then decrements it.
//////////////////////////////////////////////////////////////////// 1 4 this 3 297  
110 14 Dtool_kd_ifUgs 0 6 134 262 0 14 Dtool_kd_ifUgs 342 ////////////////////////////////////////////////////////////////////
//     Function: Semaphore::try_acquire
//       Access: Published
//  Description: If the semaphore can be acquired without blocking,
//               does so and returns true.  Otherwise, returns false.
//////////////////////////////////////////////////////////////////// 1 4 this 3 297  
111 14 Dtool_kd_iyIK2 0 6 135 260 0 14 Dtool_kd_iyIK2 401 ////////////////////////////////////////////////////////////////////
//     Function: Semaphore::release
//       Access: Published
//  Description: Increments the semaphore's internal count.  This may
//               wake up another thread blocked on acquire().
//
//               Returns the count of the semaphore upon release.
//////////////////////////////////////////////////////////////////// 1 4 this 3 297  
112 14 Dtool_kd_i_IPX 0 6 136 260 0 14 Dtool_kd_i_IPX 366 ////////////////////////////////////////////////////////////////////
//     Function: Semaphore::get_count
//       Access: Published
//  Description: Returns the current semaphore count.  Note that this
//               call is not thread-safe (the count may change at any
//               time).
//////////////////////////////////////////////////////////////////// 1 4 this 3 298  
113 14 Dtool_kd_iMF_3 0 4 137 261 0 14 Dtool_kd_iMF_3 217 ////////////////////////////////////////////////////////////////////
//     Function: Semaphore::output
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 2 4 this 3 298  3 out 1 264  
70
230 13 AsyncTaskBase 0 26625 13 AsyncTaskBase 13 AsyncTaskBase 0 0 0 0 118 0 1 119 0 0 2 3 231 114 115 3 232 116 117 0 0 346
////////////////////////////////////////////////////////////////////
//       Class : AsyncTaskBase
// Description : The abstract base class for AsyncTask.  This is
//               defined here only so we can store a pointer to the
//               current task on the Thread.
////////////////////////////////////////////////////////////////////

231 19 TypedReferenceCount 0 2049 19 TypedReferenceCount 19 TypedReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 710
////////////////////////////////////////////////////////////////////
//       Class : TypedReferenceCount
// Description : A base class for things which need to inherit from
//               both TypedObject and from ReferenceCount.  It's
//               convenient to define this intermediate base class
//               instead of multiply inheriting from the two classes
//               each time they are needed, so that we can sensibly
//               pass around pointers to things which are both
//               TypedObjects and ReferenceCounters.
//               
//               See also TypedObject for detailed instructions.
////////////////////////////////////////////////////////////////////

232 7 Namable 0 2049 7 Namable 7 Namable 0 0 0 0 0 0 0 0 0 0 0 0 324
////////////////////////////////////////////////////////////////////
//       Class : Namable
// Description : A base class for all things which can have a name.
//               The name is either empty or nonempty, but it is never
//               NULL.
////////////////////////////////////////////////////////////////////

233 14 ThreadPriority 0 532481 14 ThreadPriority 14 ThreadPriority 0 0 0 0 0 0 0 0 0 0 4 6 TP_low 6 TP_low 0 9 TP_normal 9 TP_normal 1 7 TP_high 7 TP_high 2 9 TP_urgent 9 TP_urgent 3 0 243
////////////////////////////////////////////////////////////////////
// An enumerated type used by Thread to specify a suggested relative
// priority for a particular thread.
////////////////////////////////////////////////////////////////////

234 6 Thread 0 26625 6 Thread 6 Thread 0 0 0 0 124 0 30 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 0 0 2 3 231 120 121 3 232 122 123 0 0 668
////////////////////////////////////////////////////////////////////
//       Class : Thread
// Description : A thread; that is, a lightweight process.  This is an
//               abstract base class; to use it, you must subclass
//               from it and redefine thread_main().
//
//               The thread itself will keep a reference count on the
//               Thread object while it is running; when the thread
//               returns from its root function, the Thread object
//               will automatically be destructed if no other pointers
//               are referencing it.
////////////////////////////////////////////////////////////////////

235 11 MutexDirect 0 43009 11 MutexDirect 11 MutexDirect 0 0 0 0 0 0 9 155 156 157 158 159 160 161 162 163 0 0 0 0 0 364
////////////////////////////////////////////////////////////////////
//       Class : MutexDirect
// Description : This class implements a standard mutex by making
//               direct calls to the underlying implementation layer.
//               It doesn't perform any debugging operations.
////////////////////////////////////////////////////////////////////

236 5 Mutex 0 26625 5 Mutex 5 Mutex 0 0 0 1 164 165 0 0 0 0 1 0 235 0 0 0 0 0

237 18 ConditionVarDirect 0 26625 18 ConditionVarDirect 18 ConditionVarDirect 0 0 0 0 166 0 4 167 168 169 170 0 0 0 0 0 661
////////////////////////////////////////////////////////////////////
//       Class : ConditionVarDirect
// Description : A condition variable, usually used to communicate
//               information about changing state to a thread that is
//               waiting for something to happen.  A condition
//               variable can be used to "wake up" a thread when some
//               arbitrary condition has changed.
//
//               A condition variable is associated with a single
//               mutex, and several condition variables may share the
//               same mutex.
////////////////////////////////////////////////////////////////////

238 12 ConditionVar 0 26625 12 ConditionVar 12 ConditionVar 0 0 0 1 171 172 0 1 173 0 0 1 0 237 0 0 0 0 0

239 22 ConditionVarFullDirect 0 26625 22 ConditionVarFullDirect 22 ConditionVarFullDirect 0 0 0 0 174 0 5 175 176 177 178 179 0 0 0 0 0 665
////////////////////////////////////////////////////////////////////
//       Class : ConditionVarFullDirect
// Description : A condition variable, usually used to communicate
//               information about changing state to a thread that is
//               waiting for something to happen.  A condition
//               variable can be used to "wake up" a thread when some
//               arbitrary condition has changed.
//
//               A condition variable is associated with a single
//               mutex, and several condition variables may share the
//               same mutex.
////////////////////////////////////////////////////////////////////

240 16 ConditionVarFull 0 26625 16 ConditionVarFull 16 ConditionVarFull 0 0 0 1 180 181 0 1 182 0 0 1 0 239 0 0 0 0 0

241 13 ReMutexDirect 0 43009 13 ReMutexDirect 13 ReMutexDirect 0 0 0 0 0 0 10 183 184 185 186 187 188 189 190 191 192 0 0 0 0 0 368
////////////////////////////////////////////////////////////////////
//       Class : ReMutexDirect
// Description : This class implements a standard reMutex by making
//               direct calls to the underlying implementation layer.
//               It doesn't perform any debugging operations.
////////////////////////////////////////////////////////////////////

242 7 ReMutex 0 26625 7 ReMutex 7 ReMutex 0 0 0 1 193 194 0 0 0 0 1 0 241 0 0 0 0 0

243 14 ExternalThread 0 141313 14 ExternalThread 14 ExternalThread 0 0 0 0 196 0 1 195 0 0 1 0 234 0 0 0 0 356
////////////////////////////////////////////////////////////////////
//       Class : ExternalThread
// Description : The special "external thread" class.  There is one
//               instance of these in the world, and it is returned by
//               Thread::get_external_thread().
////////////////////////////////////////////////////////////////////

244 16 LightMutexDirect 0 43009 16 LightMutexDirect 16 LightMutexDirect 0 0 0 0 0 0 8 197 198 199 200 201 202 203 204 0 0 0 0 0 372
////////////////////////////////////////////////////////////////////
//       Class : LightMutexDirect
// Description : This class implements a lightweight Mutex by making
//               direct calls to the underlying implementation layer.
//               It doesn't perform any debugging operations.
////////////////////////////////////////////////////////////////////

245 10 LightMutex 0 26625 10 LightMutex 10 LightMutex 0 0 0 1 205 206 0 0 0 0 1 0 244 0 0 0 0 0

246 18 LightReMutexDirect 0 43009 18 LightReMutexDirect 18 LightReMutexDirect 0 0 0 0 0 0 9 207 208 209 210 211 212 213 214 215 0 0 0 0 0 378
////////////////////////////////////////////////////////////////////
//       Class : LightReMutexDirect
// Description : This class implements a standard lightReMutex by making
//               direct calls to the underlying implementation layer.
//               It doesn't perform any debugging operations.
////////////////////////////////////////////////////////////////////

247 12 LightReMutex 0 26625 12 LightReMutex 12 LightReMutex 0 0 0 1 216 217 0 0 0 0 1 0 246 0 0 0 0 0

248 10 MainThread 0 141313 10 MainThread 10 MainThread 0 0 0 0 219 0 1 218 0 0 1 0 234 0 0 0 0 344
////////////////////////////////////////////////////////////////////
//       Class : MainThread
// Description : The special "main thread" class.  There is one
//               instance of these in the world, and it is returned by
//               Thread::get_main_thread().
////////////////////////////////////////////////////////////////////

249 12 PythonThread 0 75777 12 PythonThread 12 PythonThread 0 0 0 1 220 124 0 2 221 222 0 0 1 0 234 0 0 0 0 376
////////////////////////////////////////////////////////////////////
//       Class : PythonThread
// Description : This class is exposed to Python to allow creation of
//               a Panda thread from the Python level.  It will spawn
//               a thread that executes an arbitrary Python functor.
////////////////////////////////////////////////////////////////////

250 9 Semaphore 0 26625 9 Semaphore 9 Semaphore 0 0 0 1 223 224 0 5 225 226 227 228 229 0 0 0 0 0 594
////////////////////////////////////////////////////////////////////
//       Class : Semaphore
// Description : A classic semaphore synchronization primitive.  
//
//               A semaphore manages an internal counter which is
//               decremented by each acquire() call and incremented by
//               each release() call. The counter can never go below
//               zero; when acquire() finds that it is zero, it
//               blocks, waiting until some other thread calls
//               release().
////////////////////////////////////////////////////////////////////

251 10 TypeHandle 0 2048 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 1098
////////////////////////////////////////////////////////////////////
//       Class : TypeHandle
// Description : TypeHandle is the identifier used to differentiate
//               C++ class types.  Any C++ classes that inherit from
//               some base class, and must be differentiated at run
//               time, should store a static TypeHandle object that
//               can be queried through a static member function
//               named get_class_type().  Most of the time, it is also
//               desirable to inherit from TypedObject, which provides
//               some virtual functions to return the TypeHandle for a
//               particular instance.
//
//               At its essence, a TypeHandle is simply a unique
//               identifier that is assigned by the TypeRegistry.  The
//               TypeRegistry stores a tree of TypeHandles, so that
//               ancestry of a particular type may be queried, and the
//               type name may be retrieved for run-time display.
////////////////////////////////////////////////////////////////////

252 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 251 0 0 0 0 0 0 0 0 0 0

253 15 AsyncTaskBase * 0 8576 15 AsyncTaskBase * 15 AsyncTaskBase * 0 0 230 0 0 0 0 0 0 0 0 0 0

254 21 TypedReferenceCount * 0 8576 21 TypedReferenceCount * 21 TypedReferenceCount * 0 0 231 0 0 0 0 0 0 0 0 0 0

255 9 Namable * 0 8576 9 Namable * 9 Namable * 0 0 232 0 0 0 0 0 0 0 0 0 0

256 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0

257 8 Thread * 0 8576 8 Thread * 8 Thread * 0 0 234 0 0 0 0 0 0 0 0 0 0

258 14 Thread const * 0 8576 14 Thread const * 14 Thread const * 0 0 259 0 0 0 0 0 0 0 0 0 0

259 12 Thread const 0 8832 12 Thread const 12 Thread const 0 0 234 0 0 0 0 0 0 0 0 0 0

260 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0

261 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0

262 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0

263 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0

264 9 ostream * 0 8576 9 ostream * 9 ostream * 0 0 265 0 0 0 0 0 0 0 0 0 0

265 7 ostream 0 2048 7 ostream 7 ostream 0 0 0 0 0 0 0 0 0 0 0 0 0

266 10 PyObject * 0 8576 10 PyObject * 10 PyObject * 0 0 267 0 0 0 0 0 0 0 0 0 0

267 8 PyObject 0 2048 8 PyObject 8 PyObject 0 0 0 0 0 0 0 0 0 0 0 0 0

268 19 MutexDirect const * 0 8576 19 MutexDirect const * 19 MutexDirect const * 0 0 269 0 0 0 0 0 0 0 0 0 0

269 17 MutexDirect const 0 8832 17 MutexDirect const 17 MutexDirect const 0 0 235 0 0 0 0 0 0 0 0 0 0

270 13 MutexDirect * 0 8576 13 MutexDirect * 13 MutexDirect * 0 0 235 0 0 0 0 0 0 0 0 0 0

271 7 Mutex * 0 8576 7 Mutex * 7 Mutex * 0 0 236 0 0 0 0 0 0 0 0 0 0

272 26 ConditionVarDirect const * 0 8576 26 ConditionVarDirect const * 26 ConditionVarDirect const * 0 0 273 0 0 0 0 0 0 0 0 0 0

273 24 ConditionVarDirect const 0 8832 24 ConditionVarDirect const 24 ConditionVarDirect const 0 0 237 0 0 0 0 0 0 0 0 0 0

274 20 ConditionVarDirect * 0 8576 20 ConditionVarDirect * 20 ConditionVarDirect * 0 0 237 0 0 0 0 0 0 0 0 0 0

275 14 ConditionVar * 0 8576 14 ConditionVar * 14 ConditionVar * 0 0 238 0 0 0 0 0 0 0 0 0 0

276 20 ConditionVar const * 0 8576 20 ConditionVar const * 20 ConditionVar const * 0 0 277 0 0 0 0 0 0 0 0 0 0

277 18 ConditionVar const 0 8832 18 ConditionVar const 18 ConditionVar const 0 0 238 0 0 0 0 0 0 0 0 0 0

278 30 ConditionVarFullDirect const * 0 8576 30 ConditionVarFullDirect const * 30 ConditionVarFullDirect const * 0 0 279 0 0 0 0 0 0 0 0 0 0

279 28 ConditionVarFullDirect const 0 8832 28 ConditionVarFullDirect const 28 ConditionVarFullDirect const 0 0 239 0 0 0 0 0 0 0 0 0 0

280 24 ConditionVarFullDirect * 0 8576 24 ConditionVarFullDirect * 24 ConditionVarFullDirect * 0 0 239 0 0 0 0 0 0 0 0 0 0

281 18 ConditionVarFull * 0 8576 18 ConditionVarFull * 18 ConditionVarFull * 0 0 240 0 0 0 0 0 0 0 0 0 0

282 24 ConditionVarFull const * 0 8576 24 ConditionVarFull const * 24 ConditionVarFull const * 0 0 283 0 0 0 0 0 0 0 0 0 0

283 22 ConditionVarFull const 0 8832 22 ConditionVarFull const 22 ConditionVarFull const 0 0 240 0 0 0 0 0 0 0 0 0 0

284 21 ReMutexDirect const * 0 8576 21 ReMutexDirect const * 21 ReMutexDirect const * 0 0 285 0 0 0 0 0 0 0 0 0 0

285 19 ReMutexDirect const 0 8832 19 ReMutexDirect const 19 ReMutexDirect const 0 0 241 0 0 0 0 0 0 0 0 0 0

286 15 ReMutexDirect * 0 8576 15 ReMutexDirect * 15 ReMutexDirect * 0 0 241 0 0 0 0 0 0 0 0 0 0

287 9 ReMutex * 0 8576 9 ReMutex * 9 ReMutex * 0 0 242 0 0 0 0 0 0 0 0 0 0

288 24 LightMutexDirect const * 0 8576 24 LightMutexDirect const * 24 LightMutexDirect const * 0 0 289 0 0 0 0 0 0 0 0 0 0

289 22 LightMutexDirect const 0 8832 22 LightMutexDirect const 22 LightMutexDirect const 0 0 244 0 0 0 0 0 0 0 0 0 0

290 18 LightMutexDirect * 0 8576 18 LightMutexDirect * 18 LightMutexDirect * 0 0 244 0 0 0 0 0 0 0 0 0 0

291 12 LightMutex * 0 8576 12 LightMutex * 12 LightMutex * 0 0 245 0 0 0 0 0 0 0 0 0 0

292 26 LightReMutexDirect const * 0 8576 26 LightReMutexDirect const * 26 LightReMutexDirect const * 0 0 293 0 0 0 0 0 0 0 0 0 0

293 24 LightReMutexDirect const 0 8832 24 LightReMutexDirect const 24 LightReMutexDirect const 0 0 246 0 0 0 0 0 0 0 0 0 0

294 20 LightReMutexDirect * 0 8576 20 LightReMutexDirect * 20 LightReMutexDirect * 0 0 246 0 0 0 0 0 0 0 0 0 0

295 14 LightReMutex * 0 8576 14 LightReMutex * 14 LightReMutex * 0 0 247 0 0 0 0 0 0 0 0 0 0

296 14 PythonThread * 0 8576 14 PythonThread * 14 PythonThread * 0 0 249 0 0 0 0 0 0 0 0 0 0

297 11 Semaphore * 0 8576 11 Semaphore * 11 Semaphore * 0 0 250 0 0 0 0 0 0 0 0 0 0

298 17 Semaphore const * 0 8576 17 Semaphore const * 17 Semaphore const * 0 0 299 0 0 0 0 0 0 0 0 0 0

299 15 Semaphore const 0 8832 15 Semaphore const 15 Semaphore const 0 0 250 0 0 0 0 0 0 0 0 0 0

0
0
0
